[{"title":"Hello World","url":"/2021/11/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Keep 主题使用指南","url":"/2020/04/07/MySQL%E8%BF%90%E7%BB%B4%E5%B0%8F%E5%86%8C/","content":":smirk_cat: 总要热爱点什么，不能被这无趣的生活吞没。\n\n\n01 - 一文了解 MySQL 在 Linux 下的部署一. MySQL 在 CentOS7 的部署系统环境说明：\n# 内核[root@cool ~]$ uname -r3.10.0-1160.31.1.el7.x86_64# 版本[root@cool ~]$ cat /etc/redhat-releaseCentOS Linux release 7.9.2009 (Core)\n\n首先，需要去官网找到 MySQL 的下载链接：https://downloads.mysql.com/archives/community/ ，选择自己需要的版本。然后按照以下命令进行 mysql 的安装。\n[root@cool ~]$ wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.35-linux-glibc2.12-x86_64.tar.gz# 1. 解压[root@cool ~]$ tar xf mysql-5.7.35-linux-glibc2.12-x86_64.tar.gz# 2. 创建软件目录与软链接[root@cool ~]$ mkdir /mysql[root@cool ~]$ mv mysql-5.7.35-linux-glibc2.12-x86_64 /mysql[root@cool ~]$ ln -s /mysql/mysql-5.7.35-linux-glibc2.12-x86_64/ /usr/local/mysql[root@cool ~]$ ll /usr/local/mysqllrwxrwxrwx 1 root root 43 Oct 31 10:22 /usr/local/mysql -&gt; /mysql/mysql-5.7.35-linux-glibc2.12-x86_64/# 3. 创建 mysql 用户与数据目录并授权[root@cool ~]$ useradd mysql -M -s /sbin/nologin[root@cool ~]$ mkdir -p /data/3306/mysql[root@cool ~]$ chown mysql. /data -R# 4. 清理环境[root@cool ~]$ rpm -qa | grep mariadbmariadb-libs-5.5.68-1.el7.x86_64mariadb-5.5.68-1.el7.x86_64[root@cool ~]$ yum remove mariadb-libs.x86_64 -y[root@cool ~]$ rpm -qa | grep mariadb# 5. 配置环境变量[root@cool ~]$ vim /etc/profileexport PATH=/usr/local/mysql/bin:$PATH[root@cool ~]$ . /etc/profile[root@cool ~]$ mysql -Vmysql  Ver 14.14 Distrib 5.7.35, for linux-glibc2.12 (x86_64) using  EditLine wrapper# 6. 初始化数据目录[root@cool ~]$ mysqld --initialize-insecure --user=mysql --datadir=/data/3306/mysql --basedir=/usr/local/mysql# 7. 编辑基础配置文件[root@cool ~]$ vim /etc/my.cnf[mysqld]user=mysqlbasedir=/usr/local/mysqldatadir=/data/3306/mysqlsocket=/tmp/mysql.sockport=3306[mysql]socket=/tmp/mysql.sock# 8. 启动 mysql[root@cool ~]$ /usr/local/mysql/support-files/mysql.server startStarting MySQL. SUCCESS![root@cool ~]$ netstat -lntup | grep 3306tcp6       0      0 :::3306                 :::*                    LISTEN      26781/mysqld\n\n\n如果在第六步初始化数据目录出现报错：\nmysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory \n解决方案：yum install libaio-devel -y\n\n安装完成后，进行 MySQL 的启动，使用绝对路径启动太过麻烦，下面提供了几种 MySQL 的启动方式，可以选择其一进行使用：\n# 1. 绝对路径启动/关闭[root@cool ~]$ /usr/local/mysql/support-files/mysql.server startStarting MySQL. SUCCESS!# 2. service 方式启动/关闭[root@cool ~]$ cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld[root@cool ~]$ service mysqld startStarting MySQL. SUCCESS!# 3. /etc/init.d/ 方式启动/关闭[root@cool ~]$ /etc/init.d/mysqld startStarting MySQL. SUCCESS!# 4. 使用 systemctl 方式启动/关闭[root@cool ~]$ chkconfig --add mysqld[root@cool ~]$ chkconfig --listNote: This output shows SysV services only and does not include native      systemd services. SysV configuration data might be overridden by native      systemd configuration.      If you want to list systemd services use 'systemctl list-unit-files'.      To see services enabled on particular target use      'systemctl list-dependencies [target]'.mysqld         \t0:off\t1:off\t2:on\t3:on\t4:on\t5:on\t6:off[root@cool ~]$ systemctl start mysqld[root@cool ~]$ systemctl status mysqld● mysqld.service - LSB: start and stop MySQL   Loaded: loaded (/etc/rc.d/init.d/mysqld; bad; vendor preset: disabled)   Active: active (running) since Sun 2021-10-31 10:47:27 CST; 1s ago     Docs: man:systemd-sysv-generator(8)  Process: 27869 ExecStart=/etc/rc.d/init.d/mysqld start (code=exited, status=0/SUCCESS)    Tasks: 28   Memory: 169.4M   CGroup: /system.slice/mysqld.service           ├─27880 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/3306/mysql --pid-file=/data/3306/mysql/cool.pid           └─28036 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/3306/mysql --plugin-dir=/usr/local/mysql/lib/pl...Oct 31 10:47:26 cool systemd[1]: Starting LSB: start and stop MySQL...Oct 31 10:47:27 cool mysqld[27869]: Starting MySQL. SUCCESS!Oct 31 10:47:27 cool systemd[1]: Started LSB: start and stop MySQL.\n\n关于 systemctl 的管理方式，也可参照官网进行配置后使用(支持多实例管理)：https://dev.mysql.com/doc/refman/5.7/en/using-systemd.html\n至此，对于 MySQL 常规的单实例(二进制)安装完成。对于安装过程中初始化数据目录这一步骤，有以下几点需要注意：\n① 5.7 版本之前的初始化命令为：/usr/local/mysql/scripts/mysql_install_db --user=管理用户 --basedir=软件路径  --datadir=数据目录\n② 5.7 版本及其之后的版本，初始化命令为：mysqld --initialize-insecure --user=管理用户 --basedir=软件路径 --datadir=数据目录\n③ 初始化参数--initialize：生成 12 位随机四种复杂度的密码，只能用来登录，不可以进行数据库管理，在第一次登陆后对其密码进行修改(alter user root@’localhost’ identified by ‘root’;)。\n④ 初始化参数 --initialize-insecure：初始化后管理员密码为空。\n二. MySQL 配置文件初识配置文件，即为了定制化 MySQL 。在 MySQL 中，通常情况下单节点的 MySQL 只有一个配置文件。且 MySQL 内置了一定的读取顺序，越往后文件的优先级越高，后续读取的参数信息会覆盖之前的配置，对于不重复的参数配置则是进行相加处理。我们可以使用以下命令来查看 MySQL 的配置文件读取顺序：\n[root@cool ~]$ mysqld --help --verbose | grep my.cnf/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf                      my.cnf, $MYSQL_TCP_PORT, /etc/services, built-in default\n\n以此我们可以确认 MySQL 配置文件的读取顺序为：/etc/my.cnf → /etc/mysql/my.cnf → /usr/local/mysql/etc/my.cnf →  ~/.my.cnf，你可以将配置文件放在其中的任意一个位置。当然，我们也可以在启动的时候通过参数人为地指定配置文件，即--defaults-file=/tmp/my.cnf 。\n需要注意的是，当你使用了--defaults-file参数时，该参数必须作为第一个参数出现，否则会出现报错。你可以通过mysqld --help --verbose | head -50查看一些常用的参数(或搭配grep使用)。\n下面介绍下基础的配置文件，以此配置文件为例：\n[mysqld]user=mysqlbasedir=/usr/local/mysqldatadir=/data/3306/datasocket=/tmp/mysql.sockport=3306[mysql]socket=/tmp/mysql.sock\n\nMySQL 的配置文件由配置项和标签项组成。配置项即key=value，标签项则分为服务端标签和客户端标签。常见的服务端标签有[server]、[mysqld]、[mysqld_safe]，客户端标签有[client]、[msyql]、[mysqldump]。\n三. MySQL 同版本多实例部署多实例，即在一台主机上运行多个 MySQL 实例，在测试环境或者大型的集群环境中被广泛使用。从配置方式上来说，我们使用一个 MySQL Server，通过初始化多个不同的数据目录来实现多实例的效果。\n下面为具体的同版本多实例部署过程：\n# 1. 创建多个数据目录并修改属主属组(此处以两个为例)[root@cool ~]$ mkdir /data/330{7,8}/mysql -p[root@cool ~]$ chown mysql. /data/ -R# 2. 准备多个配置文件[root@cool ~]$ cat &gt;/data/3307/my.cnf &lt;&lt;EOF[mysqld]user=mysqlbasedir=/usr/local/mysql datadir=/data/3307/mysqlsocket=/tmp/mysql3307.sockport=3307EOF[root@cool ~]$ cat &gt;/data/3308/my.cnf &lt;&lt;EOF[mysqld]user=mysqlbasedir=/usr/local/mysql datadir=/data/3308/mysqlsocket=/tmp/mysql3308.sockport=3308EOF# 3. 初始化数据(假设已经配置好了MySQL Server)[root@cool ~]$ mysqld --defaults-file=/data/3307/my.cnf --initialize-insecure[root@cool ~]$ mysqld --defaults-file=/data/3308/my.cnf --initialize-insecure# 4. 启动多个实例[root@cool ~]$ mysqld_safe --defaults-file=/data/3307/my.cnf &amp;[root@cool ~]$ mysqld_safe --defaults-file=/data/3308/my.cnf &amp;# 5. 登录多个实例[root@cool ~]$ mysql -S /tmp/mysql3307.sock[root@cool ~]$ mysql -S /tmp/mysql3308.sock# 6. 可配置为远程登录(仅为测试，生产应使用强密码)mysql &gt; create user root@'%' identified by 'root';mysql&gt; grant all on *.* to root@'%';# 测试(其中ip为主机的ip地址)[root@cool ~]$ mysql -uroot -proot -hip -P3307[root@cool ~]$ mysql -uroot -proot -hip -P3308\n\n四. MySQL 不同版本多实例部署之前我们讲解了 MySQL 同版本多实例的部署，生产中还会遇到 MySQL 不同版本多实例的部署，原理与同版本一致。具体的部署过程见下：\n# 1. 准备不同版本的 MySQL 包(以5.6和5.7版本为例)[root@cool ~]$ wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.6.51-linux-glibc2.12-x86_64.tar.gz[root@cool ~]$ wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.35-linux-glibc2.12-x86_64.tar.gz# 2. 解压并创建软链接[root@cool ~]$ tar xf mysql-5.6.51-linux-glibc2.12-x86_64.tar.gz[root@cool ~]$ tar xf mysql-5.7.35-linux-glibc2.12-x86_64.tar.gz[root@cool ~]$ mv mysql-5.6.51-linux-glibc2.12-x86_64 /mysql/[root@cool ~]$ mv mysql-5.7.35-linux-glibc2.12-x86_64 /mysql/[root@cool ~]$ ln -s /mysql/mysql-5.6.51-linux-glibc2.12-x86_64/ /usr/local/mysql56[root@cool ~]$ ln -s /mysql/mysql-5.7.35-linux-glibc2.12-x86_64/ /usr/local/mysql57# 3. 创建 mysql 用户与数据目录并授权[root@cool ~]$ useradd mysql -M -s /sbin/nologin[root@cool ~]$ mkdir -p /data/33{09..10}/mysql[root@cool ~]$ chown mysql. /data -R# 4. 准备配置文件[root@cool ~]$ cat &gt;/data/3309/my.cnf &lt;&lt;EOF[mysqld]user=mysqlbasedir=/usr/local/mysql datadir=/data/3309/mysqlsocket=/tmp/mysql3309.sockport=3309EOF[root@cool ~]$ cat &gt;/data/3310/my.cnf &lt;&lt;EOF[mysqld]user=mysqlbasedir=/usr/local/mysql datadir=/data/3310/mysqlsocket=/tmp/mysql3310.sockport=3310EOF# 5. 初始化数据[root@cool ~]$ /usr/local/mysql56/scripts/mysql_install_db --user=mysql --datadir=/data/3309/mysql --basedir=/usr/local/mysql56[root@cool ~]$ /usr/local/mysql57/bin/mysqld --user=mysql --datadir=/data/3310/mysql --basedir=/usr/local/mysql57 --initialize-insecure# 6. 启动多实例[root@cool ~]$ /usr/local/mysql56/bin/mysqld_safe  --defaults-file=/data/3309/my.cnf &amp;[root@cool ~]$ /usr/local/mysql57/bin/mysqld_safe  --defaults-file=/data/3310/my.cnf &amp;# 7. 连接测试[root@cool ~]$ mysql -S /tmp/mysql3309.sock[root@cool ~]$ mysql -S /tmp/mysql3310.sock\n\n\n5.6 初始化报错：\nFATAL ERROR: please install the following Perl modules before executing /usr/local/mysql56/scripts/mysql_install_db:Data::Dumper\n解决方案：yum install autoconf -y\n\n至此，多实例部署完成。\n五. 使用 Docker 快速部署 MySQL如果你想要快速部署一个测试或个人使用的 MySQL ，那么使用 Docker 进行部署是极其便捷的。\n首先，你需要打开 Docker 关于 MySQL 的官方镜像地址：https://hub.docker.com/_/mysql ，在其中找到自己需要的 Tag (版本)，也可以直接使用默认的 laetst 最新版本进行部署使用。此处以 Tag=mysql:5.7.35 为例：\n# 1. 安装 docker : 参照阿里云 → https://developer.aliyun.com/mirror/docker-ce# step 1: 安装必要的一些系统工具sudo yum install -y yum-utils device-mapper-persistent-data lvm2# Step 2: 添加软件源信息sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# Step 3sudo sed -i 's+download.docker.com+mirrors.aliyun.com/docker-ce+' /etc/yum.repos.d/docker-ce.repo# Step 4: 更新并安装Docker-CEsudo yum makecache fastsudo yum -y install docker-ce# Step 4: 开启Docker服务sudo service docker start# 2. 创建数据目录 → 方便数据迁移[root@cool ~]$ mkdir /data/3311/mysql -p# 3. 创建/启动容器[root@cool ~]$ docker run \\--name mysql \\-v /data/3311/mysql:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=\"root\" \\-p 3311:3306 \\-d mysql:5.7.35# 验证[root@cool ~]$ docker ps -a# 4. 进入 MySQL 数据库[root@cool ~]$ docker exec -it mysql /bin/bashroot@f156e2f7ec15:/# mysql -uroot -prootmysql&gt; select user,host from mysql.user;+---------------+------------------+| user                       | host          |+---------------+------------------+| root                       | %               || mysql.session   | localhost || mysql.sys            | localhost || root                        | localhost |+---------------+------------------+4 rows in set (0.00 sec)mysql&gt; show grants for root@'%';+-------------------------------------------------------------+| Grants for root@%                                           |+-------------------------------------------------------------+| GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION |+-------------------------------------------------------------+1 row in set (0.00 sec)\n\n可以看到，通过 Docker 运行的 MySQL 默认已经创建了远程 root 用户，且授予了所有权限，所以可以直接远程连接使用。接下来对命令的一些参数进行说明：\n① --name mysql 表示容器的名称为 mysql 。\n② -v /data/3311/mysql:/var/lib/mysql 表示将本地的 /data/3311/mysql 目录挂载到容器的 /var/lib/mysql 中，可以简单理解为在容器中写入到 /var/lib/mysql 目录的数据，实际写入到了本地的 /data/3311/mysql 目录中。\n③ -e MYSQL_ROOT_PASSWORD=\"root\" 表示配置 MySQL 默认 root 用户的密码，此处配置为 root ，大家可以结合自己的实际进行强密码配置。\n④ -p 3311:3306 表示将本地的 3311 端口映射到容器的 3306 端口，可以简单理解为访问本地的 3311 端口等同于访问容器的 3306 端口。\n关于其他常见的配置参数，可以参照官方说明部分：https://hub.docker.com/_/mysql 。\n02 - MySQL 的启动与停止小结一. MySQL 的启动方式\n使用mysqld &amp;启动：首先，我们需要认识到，mysqld 是一个二进制文件，且 mysqld 仅提供了启动方式，并没有关闭方式。它在启动过程中会将日志打印到屏幕上，可以帮助我们进行排查错误。最重要的一点，mysqld 可以在启动时加上自定义参数，与配置文件冲突时，以命令行参数为准。\n\n使用mysqld_safe启动：与 mysqld 一样，mysqld_safe 也支持自定义参数，仅提供了启动方式。不同的是，mysqld_safe 是脚本文件，启动过程中的日志会保存到日志文件中。且运行过程会自动地监控 mysqld 的状态，在必要时会自动重启 mysqld 。注意，msyqld 与 mysqld_safe 一般只在特殊情况下使用。\n\n基于脚本的方式启动：\n# 方式一：/usr/local/mysql/support-files/mysql.server start/stop/restart/status# 方式二：需要将 mysql.server 拷贝到 /etc/init.d/mysqld/etc/init.d/mysqld start/stop/restart/status\n基于service服务(CentOS7之前) 的方式启动：service mysqld start/stop/restart/status ，前提需要将 mysql.server 拷贝到 /etc/init.d/mysqld 。\n\n基于systemd 服务(CentOS7之后)的方式启动：systemctl start/stop/restart/status mysqld，前提是需要进行 systemd 配置 。\n\n\n二. MySQL 的停止方式\nservice mysqld stop：不管是通过什么方式启动的，均可使用该种方式关闭 MySQL。\nsystemctl stop mysqld：仅使用 systemd 启动的数据库可以使用该种方式停止。\nmysql&gt; shutdown;：登录进数据库，然后输入 shutdown 命令进行关闭，注意仅 5.7 及其之后的版本支持。\nmysql&gt; set global innodb_fast_shutdown=0;：同样需要登录进入数据库，此为平滑关闭数据库，一般在进行重要的运维工作时使用(例如升级数据库版本 → https://dev.mysql.com/doc/refman/5.7/en/upgrade-binary-package.html)。\nmysqladmin -uroot -proot shutdown：使用免交互的方式关闭数据库。\n\n03 - 你见过这么详细的 MySQL 升级笔记吗一. MySQL 在 Linux 中的升级开始之前，我们需要了解 MySQL 的升级方式，在官方文档中我们可以看到 MySQL 基于二进制的升级，分为 In-Place Upgrade (就地升级) 和 Logical Upgrade (逻辑升级) 两种方式。本文主要讨论 In-Place Upgrade 升级方式(适合主从环境)。\n首先，这里举出使用 In-Place Upgrade 进行版本升级的一些注意事项：\n① 支持 GA 版本之间的升级(GA 版本，即 General Availability，正式发布版)\n② 升级时，MySQL 5.6 → MySQL 5.7，建议先将 MySQL 5.6 升级至小版本的最新版本，再升级到 MySQL 5.7\n③ 升级时，MySQL 5.5 → MySQL 5.7，建议先将 MySQL 5.5 升级至小版本的最新版本，再 MySQL 5.5 → MySQL 5.6 最新版本，最后 MySQL 5.6 → MySQL 5.7 \n④ 回退方案需要提前进行准备，注意备份(特别是跨大版本升级 → 8.0 版本)\n⑤ 在合适的时间进行升级，降低业务停机时间\n其次，In-Place Upgrade 的升级原理(过程)也是我们需要掌握的。首先，需要备份原库的数据 → 部署新版本的数据库软件 → 关闭原数据库(业务停机、提前做好用户通知) → 更改配置文件，以安全方式(–skip-grant-tables、–skip-networking)启动新版本数据库，挂低版本数据库数据 → 开始升级(仅会更新一些系统表，升级时间与数据量无关) → 正常重启数据库 → 测试业务功能 → 恢复业务 → 升级完成。\nMySQL 5.x 升级到 MySQL 5,y 与 MySQL 5.x 升级到 MySQL 8.y 的过程是不同的，因为在升级到 MySQL 8.0 之前，我们有了新的工具(mysqlsh)，可以在升级前进行预检查来提升升级的可靠性。 下面，对两种不同版本的升级过程进行详细的过程演示(仅为测试环境简单演示，生产环境需要考虑的问题很多，需要依据实际情况进行升级)。\n二. MySQL 5.x → MySQL 5.y 的升级过程官方文档在此：https://dev.mysql.com/doc/refman/5.7/en/upgrade-before-you-begin.html 。\n本文以 MySQL 5.6.51 升级到 MySQL 5.7.35 为例。首先，你需要确保自己的系统中已经部署好了MySQL 5.6.51 的数据库，添加一些测试数据来测试升级过程的数据完整性。\n[root@cool ~]$ mysql -Vmysql  Ver 14.14 Distrib 5.6.51, for linux-glibc2.12 (x86_64) using  EditLine wrapper[root@cool ~]$ service mysqld startStarting MySQL. SUCCESS![root@cool ~]$ mysqlServer version: 5.6.51 MySQL Community Server (GPL)mysql&gt; create database inplace_test;mysql&gt; create table inplace_test.test(name varchar(10));mysql&gt; insert into inplace_test.test(name) values ('linus'),('zeus');mysql&gt; select * from inplace_test.test;+-------+| name  |+-------+| linus || zeus  |+-------+\n\n这里我们简单创建两个记录便于测试，备份的过程此处省略，直接从新版本数据库的部署开始。\n# 1. 部署 MySQL 5.7.35 数据库软件[root@cool ~]$ wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.35-linux-glibc2.12-x86_64.tar.gz[root@cool ~]$ tar xf mysql-5.7.35-linux-glibc2.12-x86_64.tar.gz -C /mysql/[root@cool ~]$ ln -s /mysql/mysql-5.7.35-linux-glibc2.12-x86_64/ /usr/local/mysql57# 2. 平滑关闭 MySQL 5.6.51 数据库[root@cool ~]$ mysqlmysql&gt; set global innodb_fast_shutdown=0;[root@cool ~]$ mysqladmin -uroot shutdown[root@cool ~]$ netstat -lntup | grep 3306# 3. 更改配置文件(basedir)，以安全方式启动新版本数据库，挂低版本数据库数据[root@cool ~]$ vim /etc/my.cnf[mysqld]user=mysqlbasedir=/usr/local/mysql57datadir=/data/3306/mysqlsocket=/tmp/mysql.sockport=3306[mysql]socket=/tmp/mysql.sock[root@cool ~]$ /usr/local/mysql57/bin/mysqld_safe --defaults-file=/etc/my.cnf --skip-grant-tables --skip-networking &amp;[root@cool ~]$ ll /tmp/mysql.socksrwxrwxrwx 1 mysql mysql 0 Nov  3 15:02 /tmp/mysql.sock# 4. 升级[root@cool ~]$ /usr/local/mysql57/bin/mysql_upgrade -S /tmp/mysql.sock --forceChecking server version....Upgrade process completed successfully.Checking if update is needed.# 5. 正常重启数据库[root@cool ~]$ /usr/local/mysql57/bin/mysqladmin -S /tmp/mysql.sock shutdown[root@cool ~]$ /usr/local/mysql57/support-files/mysql.server startStarting MySQL. SUCCESS!# 6. 验证[root@cool ~]$ /usr/local/mysql57/bin/mysqlServer version: 5.7.35 MySQL Community Server (GPL)mysql&gt; select * from inplace_test.test;+-------+| name  |+-------+| linus || zeus  |+-------+# 7. 修改环境变量配置(之前的为 MySQL 5.6.51 的配置)，方便服务的启停[root@cool ~]$ vim /etc/profileexport PATH=$PATH:/usr/local/mysql57/bin[root@cool ~]$ . /etc/profile[root@cool ~]$ rm -rf /etc/init.d/mysqld[root@cool ~]$ systemctl daemon-reload[root@cool ~]$ cp /usr/local/mysql57/support-files/mysql.server /etc/init.d/mysqld[root@cool ~]$ service mysqld restartShutting down MySQL.. SUCCESS!Starting MySQL. SUCCESS![root@cool ~]$ mysqlServer version: 5.7.35 MySQL Community Server (GPL)\n\n三. MySQL 5.x → MySQL 8.y 的升级过程老规矩，官方文档看这里： https://dev.mysql.com/doc/refman/8.0/en/upgrade-before-you-begin.html 。\n本文以 MySQL 5.7.35 升级到 MySQL 8.0.26 为例。首先，你需要确保自己的系统中已经部署好了MySQL 5.7.35 的数据库，添加一些测试数据来测试升级过程的数据完整性(本文中使用上文升级后的 .7 数据库，测试数据同上)。备份的过程此处省略，直接从新版本数据库的部署开始。\n# 1. 升级前预检查# ① 安装 mysqlsh 工具 → 需要与升级版本对应[root@cool ~]$ wget https://downloads.mysql.com/archives/get/p/43/file/mysql-shell-8.0.26-linux-glibc2.12-x86-64bit.tar.gz[root@cool ~]$ tar xf mysql-shell-8.0.26-linux-glibc2.12-x86-64bit.tar.gz -C /mysql/[root@cool ~]$ ln -s /mysql/mysql-shell-8.0.26-linux-glibc2.12-x86-64bit/ /usr/local/mysqlsh[root@cool ~]$ vim /etc/profileexport PATH=$PATH:/usr/local/mysqlsh/bin[root@cool ~]$ . /etc/profile[root@cool ~]$ mysqlsh -Vmysqlsh   Ver 8.0.26 for Linux on x86_64 - for MySQL 8.0.26 (MySQL Community Server (GPL))# ② 低版本数据库中新建测试用户[root@cool ~]$ mysqlServer version: 5.7.35 MySQL Community Server (GPL)mysql&gt; create user upgrade_user@'%' identified by '12345';mysql&gt; grant all on *.* to upgrade_user@'%';# ③ 进行升级前预检查(ip为你的数据库主机ip)[root@cool ~]$ mysqlsh upgrade_user:12345@'ip:3306' -e \"util.checkForServerUpgrade()\" &gt;&gt;/tmp/upgrade-test.logWARNING: Using a password on the command line interface can be insecure.[root@cool ~]$ tail -5 /tmp/upgrade-test.logErrors:   0Warnings: 1Notices:  1No fatal errors were found that would prevent an upgrade, but some potential issues were detected. Please ensure that the reported issues are not significant before upgrading.# 没有 errors 即可，一般会有一条 warning ，即密码插件的不兼容问题# 2. 部署 MySQL 8.0.26 数据库软件[root@cool ~]$ wget https://downloads.mysql.com/archives/get/p/23/file/mysql-8.0.26-linux-glibc2.12-x86_64.tar.xz[root@cool ~]$ tar xf mysql-8.0.26-linux-glibc2.12-x86_64.tar.xz -C /mysql/[root@cool ~]$ ln -s /mysql/mysql-8.0.26-linux-glibc2.12-x86_64/ /usr/local/mysql8# 3. 平滑关闭 MySQL 5.7.35 数据库mysql&gt; set global innodb_fast_shutdown=0 ;Query OK, 0 rows affected (0.00 sec)mysql&gt; select @@innodb_fast_shutdown;+-------------------------------------+| @@innodb_fast_shutdown |+-------------------------------------+|                      0            |+-------------------------------------+mysql&gt; shutdown;[root@cool ~]$ netstat -lntup | grep 3306# 4. 更改配置文件(basedir、默认密码插件)，以安全方式启动新版本数据库，挂低版本数据库数据，启动过程自动升级[mysqld]user=mysqlbasedir=/usr/local/mysql8datadir=/data/3306/mysqlsocket=/tmp/mysql.sockport=3306default_authentication_plugin=mysql_native_password[mysql]socket=/tmp/mysql.sock[root@cool ~]$ /usr/local/mysql8/bin/mysqld_safe --defaults-file=/etc/my.cnf --skip-grant-tables --skip-networking &amp;[root@cool ~]$  ll /tmp/mysql.socksrwxrwxrwx 1 mysql mysql 0 Nov  3 16:24 /tmp/mysql.sock# 5. 正常重启数据库[root@cool ~]$ /usr/local/mysql8/bin/mysqladmin -S /tmp/mysql.sock shutdown[root@cool ~]$ /usr/local/mysql8/support-files/mysql.server startStarting MySQL. SUCCESS!# 6. 验证[root@cool ~]$ /usr/local/mysql8/bin/mysqlServer version: 8.0.26 MySQL Community Server - GPLmysql&gt; select * from inplace_test.test;+-------+| name  |+-------+| linus || zeus  |+-------+# 7. 修改环境变量配置(之前的为 MySQL 5.7.35 的配置)，方便服务的启停[root@cool ~]$ vim /etc/profileexport PATH=$PATH:/usr/local/mysql8/bin[root@cool ~]$ . /etc/profile[root@cool ~]$ rm -rf /etc/init.d/mysqld[root@cool ~]$ systemctl daemon-reload[root@cool ~]$ cp /usr/local/mysql8/support-files/mysql.server /etc/init.d/mysqld[root@cool ~]$ service mysqld restartShutting down MySQL.. SUCCESS!Starting MySQL. SUCCESS![root@cool ~]$ mysqlWelcome to the MySQL monitor.  Commands end with ; or \\g.Your MySQL connection id is 8Server version: 8.0.26 MySQL Community Server - GPL\n\n\nmysqlsh 工具\n下载地址：https://downloads.mysql.com/archives/shell/\n参数说明：https://dev.mysql.com/doc/mysql-shell/8.0/en/mysqlsh.html\n\n至此，MySQL 的升级完成。\n关于密码插件的说明：8.0 版本之前，MySQL 的加密插件默认使用的是 mysql_native_password。8.0 及其之后的版本，加密插件默认使用的是caching_sha2_password。新插件可能造成某些低版本的网站连接不到数据库，为了兼容网站可以修改其加密插件为 mysql_native_password，例如：\nalter user linus@'localhost' identified with mysql_native_password by 'linus';\n\n04 - 你真的熟悉 MySQL 的架构吗一. 架构分析首先来一张图看看：\n\n总体来说的话，MySQL 分为 Server 层和存储引擎层两个部分。\nServer 层包括连接器、查询缓存、分析器、优化器、执行器等。\n存储引擎层负责的是数据的存储和提取，架构方式是插件式的，支持 Innodb、MyISAM、Memory 等多种存储引擎，不同的存储引擎共用一个 Server 层，可以使用show engines;命令来查看存储引擎列表以及当前版本的支持情况。现在最常用的存储引擎是 Innodb ，是从 MySQL 5.5.5 版本开始成为默认存储引擎的。当然，虽然有了默认的存储引擎，你依然可以使用engine=memory来指定使用特定引擎(此处为内存引擎)创建表。\n连接器负责管理连接和权限验证，需要注意的一点是一旦连接建立，那么这个连接所持有的权限就是连接器在权限表中查询到的权限，连接建立后再修改该用户的权限，需要重新连接才可以生效。可以使用show processlist;命令查看连接。客户端长时间没有操作的时候，连接器会自动将其断开，这个时间是由 wait_timeout 控制的，默认是 8 个小时。\n接下来说一下查询缓存。MySQL 拿到一个查询语句后，会先到查询缓存中看看是否执行过这条语句，之前查询过的语句会以 key-value 键值对的方式直接缓存到内存中。如果缓存命中，则会将结果直接返回给客户端，不再进行之后的操作；如果没有命中，则会继续执行下面的过程，执行完成后将执行结果存入到查询缓存中。一般是不推荐使用查询缓存的，因为查询缓存特别容易失效，一旦一个表有更新，那么基于这个表的查询缓存就会失效。可以将参数 query_cache_type 配置为 demand ，这样默认的查询就不会进行缓存，需要的时候可以使用 sql_cache 进行显式地指定。比如：\nmysql&gt; select SQL_CACHE * from T where ID=10;\n\n需要注意的是 8.0 版本开始就没有查询缓存这个功能了。\n分析器。分析器首先会进行词法分析，对 SQL 语句中的字符串进行识别。基于词法分析的结果，语法分析器会根据语法规则判断输入的 SQL 语句是否满足 MySQL 语法要求。\n经过分析器之后，MySQL 就会知道 SQL 语句需要做什么了。在执行之前，还需要进行优化器的处理。优化器会基于代价生成执行计划，也就是选择索引的过程，也包括了多表连接时各个表的连接顺序的选择等等。\n优化器之后，执行器就会真正地执行 SQL 语句。开始执行时，会先对权限进行判断，如果没有权限则会出现没有权限的错误提示；有权限时，执行器会根据表的引擎定义，调用这个引擎提供的接口从磁盘拿到相关数据页(内存中没有的话)，完成 SQL 语句的执行。\n\n慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。\n\n二. 查询语句的执行过程执行语句前要先连接数据库，这是连接器的工作。如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。\n连接建立完成后，会先到查询缓存看看，之前是不是执行过这条语句。如果命中缓存，则直接返回结果。如果没有命中，则进行下面的流程。\n分析器先会做”词法分析”，识别出你写的 SQL 中的字符串分别代表什么。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。 \n经过分析器后，还需要经过优化器的处理。优化器会基于代价生成执行计划，也就是选择索引的过程，也包括了多表连接时各个表的连接顺序的选择等等。\n优化器之后，执行器就会真正地执行 SQL 语句。开始执行时，会先对权限进行判断，如果没有权限则会出现没有权限的错误提示；有权限时，执行器会根据表的引擎定义，调用这个引擎提供的接口从磁盘拿到相关数据页(内存中没有的话)，将所有满足条件的行组成的记录集作为结果集返回给客户端，完成 SQL 语句的执行。\n三. 更新语句执行流程(事务流程)执行语句前要先连接数据库，这是连接器的工作。\n在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。\n接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。\n执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。当然要注意的是，如果使用的是唯一索引会进行上述过程，如果是普通索引的话，会用到 innodb 的 change buffer 。即该数据页不在内存中时，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。\n将对应的数据页调取到内存(buffer pool)后，会先生成 undo 日志，即前镜像用于回滚。在 Log Buffer 中会生成 undo 的 redo，然后 undo 日志落地，之后才会在内存中更新数据页。\n接下来就是两阶段提交，即 2PC 机制，也就是将 redo log 的写入拆成了两个步骤，prepare 和 commit 。首先第一阶段，内存中数据页更新后，会将更新操作记录到 redo log 中，此时 redo log 会被标记为 prepare 状态，告知执行器执行完成，随时可以提交事务。\n接着是第二阶段，执行器生成这个操作的 binlog，并把 binlog 写入磁盘，即 binlog 落地，然后执行器调用引擎的提交事务接口，引擎把 redo log 改成 commit 状态，此时事务或者这个更新就完成了。\n当然最后 Innodb 会将这个操作记录更新到磁盘上，这里会用到 Innodb 的 DWB ，即 double write buffer 双写缓冲区。每次写数据之前先分两次，每次 1M 向 DWB 中写，写成功后再写入到表空间中，这样的话可以防止数据库宕机造成数据页损坏的时候，可以通过 DWB 对 page 进行修复。\n\n如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。\n粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging ，日志先行。关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。利用 WAL 技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能。\n当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log(粉板)里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。\n\n05 - 划重点之 MySQL 中的日志一. redo 日志是个什么玩意redo log ，即重做日志，记录的是数据被修改之后的值，由 redo log buffer 和 redo log file 组成。存储位置在 data 目录下的 ib_logfile0、ib_logfile1 ，MySQL 在使用时先使用第一个，满了之后使用第二个，然后再覆盖使用第一个，循环使用。\n每次更新数据，先更新 redo log buffer 中的值，然后根据 innodb_flush_log_at_trx_commit 的值来控制 redo log 刷盘的时机。\ninnodb_flush_log_at_trx_commit 参数用来控制 redo log 的刷盘时机。其值有：\n官方文档：\nThe default setting of 1 is required for full ACID compliance. Logs are written and flushed to disk at each transaction commit.\nWith a setting of 0, logs are written and flushed to disk once per second. Transactions for which logs have not been flushed can be lost in a crash.\nWith a setting of 2, logs are written after each transaction commit and flushed to disk once per second. Transactions for which logs have not been flushed can be lost in a crash.\n\n\n\n值\n解释\n\n\n\n0\n每秒写入到日志文件并刷写(flush)到磁盘，配置该值时 MySQL 性能最好，但如果 mysqld 进程崩溃，通常会导致最后 1s 的日志丢失。即每次事务提交时都只是把 redo log 留在 redo log buffer 中\n\n\n1\n每次事务提交时写入到日志文件并刷写到磁盘，最安全，但性能最低。即每次事务提交时都将 redo log 直接持久化到磁盘\n\n\n2\n每次事务提交均会写入日志文件，但并不会立即刷写到磁盘，日志文件会每秒刷写一次到磁盘。即每次事务提交时都只是把 redo log 写到 page cache\n\n\nInnoDB 中 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块”粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。\n\nwrite pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。\n如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe 。\n\n一个内存配置为 128GB、innodb_io_capacity 设置为 20000 的大规格实例，正常会建议你将 redo log 设置成 4 个 1 GB 的文件。\n\n二. binlog 日志是个什么玩意binlog ，即二进制日志、归档日志，记录了所有的 DDL (数据定义语句)和 DML (数据操纵语句)，不包括 select 和 show 的操作。\nbinlog 的应用场景：数据恢复、复制(主从同步)、审计数据的变更操作。\n可以通过 sync_binlog 的值来控制 binlog 日志 fsync 到磁盘的时机，可以配置 0 、1 或者大于 1 的数字。\n官方文档：\nsync_binlog=0：Disables synchronization of the binary log to disk by the MySQL server. Instead, the MySQL server relies on the operating system to flush the binary log to disk from time to time as it does for any other file. This setting provides the best performance, but in the event of a power failure or operating system crash, it is possible that the server has committed transactions that have not been synchronized to the binary log.\nsync_binlog=1：Enables synchronization of the binary log to disk before transactions are committed. This is the safest setting but can have a negative impact on performance due to the increased number of disk writes. In the event of a power failure or operating system crash, transactions that are missing from the binary log are only in a prepared state. This permits the automatic recovery routine to roll back the transactions, which guarantees that no transaction is lost from the binary log.\nsync_binlog=N, where N is a value other than 0 or 1: The binary log is synchronized to disk after N binary log commit groups have been collected. In the event of a power failure or operating system crash, it is possible that the server has committed transactions that have not been flushed to the binary log. This setting can have a negative impact on performance due to the increased number of disk writes. A higher value improves performance, but with an increased risk of data loss.\n\n\n\n值\n解释\n\n\n\n0\nbinlog 日志刷盘时机依赖 OS 刷盘机制，由操作系统决定，即每次提交事务都只 write，不 fsync\n\n\n1\n每次事务提交均进行刷盘，即每次提交事务都会执行 fsync\n\n\nn(n&gt;1)\n每 n 次事务提交后落盘一次，如果此时数据库崩溃，可能丢失 n 个事务的 binlog 。即表示每次提交事务都 write ，但累积 n 个事务后才 fsync\n\n\n在出现 IO 瓶颈的场景里，将 sync_binlog 设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成 0，比较常见的是将其设置为 100~1000 中的某个数值。但是，将 sync_binlog 设置为 N，对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。\nbinlog 有两种模式，statement 格式的话是记 sql 语句， row 格式会记录行的内容，记两条，更新前和更新后都有。\n三. redo log 与 binlog 的区别\nredo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。\nredo log 是物理日志，记录的是”在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如”给 ID=2 这一行的 c 字段加 1 “。\nredo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。”追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\n\n四. undo 日志与 MVCCundo log 是逻辑日志，用于回滚，将数据库逻辑地恢复到原来的样子，存储位置默认在 data 目录下的 undo_001、undo_002 ，默认两个文件，undo 表空间在 8.0 之后支持通过语句的方式在线添加。\n除了回滚，undo  log 的另一个作用是 MVCC 。InnoDB 存储引擎中 MVCC 的实现是通过 undo 来完成的。当用户读取一行记录时，若该记录已经被其它事务占用，当前事务可以通过 undo log 读取之前的行版本信息，以此实现非锁定读取。\n回滚日志会在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除，即当系统里没有比这个回滚日志更早的 read-view 的时候。\n\n在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。\n\nundo 了解后，我们来说说 MVCC 的事。MVCC ，即多版本并发控制，在 RC 和 RR 级别下工作。是通过保存数据在某个时间点的快照来实现的，也就是说每个事务看到的数据是一致的。在 RC 和 RR 隔离级别下，如果需要查询一些被其它事务正在更新的行，看到的是这些记录被更新之前的值。而这就是用 MVCC 实现的。\n\n在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。即同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）\n\n从原理上来看，InnoDB 存储引擎中 MVCC 的实现是通过 undo 来完成的。InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。\nMVCC 的最大优势是读不加锁、读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC ，实现了 ACID 特性中的 I 特性(隔离性)。\nx. 什么是两阶段提交两阶段提交，即 2PC 机制，也就是将 redo log 的写入拆成了两个步骤，prepare 和 commit 。首先第一阶段，内存中数据页更新后，会将更新操作记录到 redo log 中，此时 redo log 会被标记为 prepare 状态，告知执行器执行完成，随时可以提交事务。\n接着是第二阶段，执行器生成这个操作的 binlog，并把 binlog 写入磁盘，即 binlog 落地，然后执行器调用引擎的提交事务接口，引擎把 redo log 改成 commit 状态，此时事务或者这个更新就完成了。\n如果不使用两阶段提交，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致，或者在扩容增加从库来提升系统的读能力的时候，使用全备 + binlog 的方式也会造成主从数据不一致的状况。比如把数据库一条记录中的 0 改为 1，,假如先写 redo 后写 binlog ，在 redo 写完之后，binlog 还没写就 crash 了，系统依靠 redo 自动故障恢复了，那么数据库恢复后该值为 1 ，但是存起来的 binlog 中没有记录该语句，之后依靠 binlog 就会出现数据不一致的状况。\n要是写完 binlog ，在写 redo log 之前 crash 了，那么崩溃恢复后因为没有写 redo ，该值还是为 0 ，但是 binlog 中记录的是该值变为 1 了，之后用 binlog 恢复的时候也会出现数据不一致。\n在两阶段提交机制下，如果 redolog 只是完成了 prepare，而 binlog 又失败，那么事务本身会回滚，所以该值还是 0 ，如果通过 binlog 恢复出一个库，该值也是 0 ，这样就保证了一致性。\n特殊情况：如果 binlog 已经写入，redolog 是 prepare 状态，此时触发崩溃恢复机制，那么 MySQL 会认可这个事务，将其提交掉，这种情况下用 binlog 恢复的库和原库逻辑上也是一致的。\nMySQL 中正常事务提交是要 commit 才算完，但是崩溃恢复过程的话，可以接受 redolog prepare 并且 binlog 完整的情况。\n所以两阶段提交将 redo log 的写入分为两个阶段，从逻辑上保证了 redo log 和 binlog 的一致性。\n06 - 深入对于事务的理解一. 认识事务与事务的 ACID 特性事务就是一组原子性的 SQL 查询，或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。 比如我给朋友转账的过程，必须放在一个事务中进行。\n\n事务支持是在引擎层实现的。MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。\n\n① atomicity(原子性) [ˌætəm’ɪsɪti]：要么全执行，要么全都不执行。由 undo 和 redo 来进行保证。\n② consistency(一致性) [kənˈsɪstənsi]：在事务开始和完成时，数据都必须保持一致状态。由 DBW 和自动故障恢复来保证。\n③ isolation(隔离性)[ˌaɪsəˈleɪʃn] ：多个并发事务之间互不影响。由隔离级别、锁、MVCC 来保证。\n④ durability(持久性) [ˌdjʊərəˈbɪləti]：事务完成之后，它对于数据的修改是永久性的。由 redo 来保证。\n二. 事务的隔离级别初识当数据库上有多个事务同时执行的时候，就可能出现**脏读(dirty read)、不可重复读(non-repeatable read)、幻读(phantom read)**的问题，为了解决这些问题，就有了“隔离级别”的概念，隔离得越严实，效率就会越低。SQL 标准的事务隔离级别包括：\n① **Read uncommitted (读未提交，简称 RU)**：在该隔离级别，所有事务都可以看到其它未提交事务的执行结果。可能会出现脏读(dirty read)、不可重复读(non-repeatable read)、幻读(phantom read)[‘fæntəm]的问题。\n② **Read Committed (读已提交，简称 RC)**：一个事务只能看见已经提交事务所做的改变。因为同一事务的其它实例在该实例处理期间可能会有新的 commit，所以可能出现幻读和不可重复读问题。\n③ **Repeatable Read(可重复读，简称 RR)**：这是 MySQL 的默认事务隔离级别，可以确保一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的，简单来说就是事务在执行期间看到的数据前后必须是一致的。可能出现幻读问题。\n④ **Serializable(串行化)**：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。即对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。\n四种隔离级别相关的配置方法见下：\n# 5.7 引入了 transaction_isolation 用来替换 tx_isolation ，到 8.0.3 就去掉了后者了。show variables like 'transaction_isolation';set session transaction_isolation='READ-UNCOMMITTED'; # 设置会话隔离级别为 RUset session transaction_isolation='READ-COMMITTED'; # 设置会话隔离级别为 RCset session transaction_isolation='REPEATABLE-READ'; # 设置会话隔离级别为 RR\n\nRU 和 Serializable 在生产环境中几乎不用。如果能接受幻读，需要并发高一点，就可以配置成 RC，如果不能接受幻读的情况，就设置成 RR 隔离级别。\n\n面试：我上家公司选择的是 RC 隔离级别，因为 RC 级别下的事务已经是提交了的事务，我们的业务可以容忍不可重复读的问题。之前用 RR 级别的话业务有时会出现大量的间隙锁报警，所以最终选用了 RC 级别，主要是减少锁的产生。\n\n不可重复读是针对数据的修改造成的读不一致，而幻读是针对数据的插入和删除造成的读不一致，如同发生幻觉一样。\n那么，RR 级别有什么样的应用场景呢？比如在银行业务的数据校对上，我在最后一天晚上 00:00 执行了查询语句，那么我在校对上个月报表数据的时候，即使 00:00 之后有用户发生了一笔新的交易，也不影响我的校对结果。这时候使用可重复读隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。\n在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。该视图是基于 MVCC 的。读未提交隔离级别下直接返回记录上的最新值，没有视图概念。读已提交隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。可重复读隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。串行化隔离级别下直接用加锁的方式来避免并行访问。\n三. 如何开启/关闭一个事务显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。\nset autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。\n有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。因此，我会建议你总是使用 set autocommit=1, 通过显式语句的方式来启动事务。\n相对于 set autocommit=0 ，设置为 1 后的”多一次交互”的问题，在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。\nbegin 或者 start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。\n需要注意的是：第一种启动方式，一致性视图是在执行第一个快照读语句时创建的； 第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。\nRC 级别下 start transaction with consistent snapshot 等效于 start transaction。\n四. 事务的隐式回滚和隐式提交隐式回滚的情况有：事务中连接断开、数据库宕机、死锁。\n隐式提交的情况有：DDL(alter、create、drop)、DCL(grant、revoke)、锁定语句(lock tables xxx read/write、unlock tables)、set autocommit=1、同一会话中事务未关闭再次开启一个事务。\n五. 长事务的坏处与避免的方法如何判断一个事务是否是长事务呢？可以在 information_schema 库的 innodb_trx 这个表中查询长事务。innodb_trx 表存储了在 innodb 中正在执行的事务的一些基本信息。\n# 查找持续时间超过 60s 的事务select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60;# TIME_TO_SEC(time) → 函数返回将参数 time 转换为秒数的时间值# TIMEDIFF(dt1, dt2); → 函数接受两个必须为相同类型的参数，即 TIME 或 DATETIME，返回表示为时间值的 dt1-dt2 的结果\n\n长事务意味着系统里面会存在很老的事务视图，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。\n综上所述，我们应该尽量避免长事务。有以下几个方法可以参考：\n① 从应用开发端来看，确认应用是否使用了 set autocommit=0 。\n② 从数据库层面来看的话，监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；在业务功能测试阶段要求输出所有的日志，分析日志行为提前发现问题。\n③ 如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2 (或更大的值)。如果真的出现大事务导致回滚段过大，这样设置后清理起来更加方便。\n\n在 MySQL 5.6 中开始支持把 undo log 分离到独立的表空间，并放到单独的文件目录下。该操作必须在初始化实例的时候进行配置。MySQL 8.0 开始默认会创建两个 undo 独立表空间。\n\n0x - 遇到的 MySQL 故障总结梳理\nMySQL 长连接问题\n\n现象：监控报警，MySQL 内存持续上升，最后 MySQL 异常重启\n\n分析：查看 show processlist 有大量连接，并且监控曲线图是持续上升的，推测可能是因为使用长连接导致的。因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉(OOM)，从现象看就是 MySQL 异常重启了。\n\n解决：可以考虑以下两种方案。\n思路一：定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。\n思路二：当时我们使用的是 MySQL 5.7，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。(返回值为 0 表示执行成功，非零表示执行失败)\n\n\n\n\n","categories":["Hexo"],"tags":["Hexo"]}]