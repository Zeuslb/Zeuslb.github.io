<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>nfs 服务部署与实践</title>
    <url>/2020/12/15/NFS%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="一-存储服务初识"><a href="#一-存储服务初识" class="headerlink" title="一. 存储服务初识"></a>一. 存储服务初识</h3><p><strong>NFS 存储服务概念说明</strong></p>
<p>NFS 是 Network File System 的缩写，即网络文件系统，其主要功能是通过网络 (一般为局域网) 让不同的主机之间可以共享文件或目录。</p>
<p>NFS 客户端 (一般为应用服务器，例如 web) 可以通过挂载 (mount) 的方式将 NFS 服务端共享的数据目录挂载到 NFS 客户端本地系统中。从客户端本地看，NFS 服务器端共享的目录就好像是客户端自己的磁盘分区或者目录一样，但实际访问的是 NFS 服务器的目录。</p>
<p>第一个网络文件系统被称为 File Access Listener，由 Digital Equipment Corporation (DEC) 在 1976 年开发。NFS 是第一个构建于 IP 协议之上的现代网络文件系统。</p>
<p><strong>NFS 存储服务的作用</strong></p>
<p>对于多台网站服务器，经过负载均衡调度之后用户数据分别上传到不同 web 服务器磁盘中时会出现数据不一致的问题 。</p>
<p>如果对多台 web 服务器均进行实时无差异的数据同步，部署会很麻烦，并且浪费磁盘空间。存储服务器的出现可以实现数据存储的统一性(即共享)，也可以节省架构服务器磁盘的成本开销(web服务器磁盘只需满足系统安装即可，存储服务器按需进行磁盘扩容)。</p>
<p><strong>NFS 存储服务的应用</strong></p>
<p>对于中小型企业，采用 NFS 或者 Samba 即可充分满足数据存储的应用。对于中大型企业，建议采用分布式存储MooseFS(mfs)、GlusterFS、FastDFS或者专业硬件存储 EMC (戴尔)。</p>
<p>在企业集群架构的工作场景中，NFS 网络文件系统一般被用来存储共享视频、图片、附件等静态资源文件，通常网站用户上传的文件都会放在 NFS 共享里。</p>
<p>共享存储的位置可以通过开源软件和商业硬件实现，互联网中小型集群架构会用普通 PC 服务器配置 NFS 网络文件系统实现。硬件实现可以利用 IOE(IBM Oracle EMC) 相应的硬件设备实现，但去 IOE 正在成为互联网公司的主流。</p>
<p><strong>NFS 在网络文件共享服务作用总结</strong></p>
<ol>
<li>负载均衡设备会将访问流量进行分流，不便于文件和数据的互相访问 ；</li>
<li>利用服务器间的数据同步可以实现用户之间数据互访，但同步管理操作过于复杂 ；</li>
<li>利用 NFS 服务器可以统一管理数据，使得用户之间可以顺利互访。</li>
</ol>
<h3 id="二-NFS-工作原理"><a href="#二-NFS-工作原理" class="headerlink" title="二. NFS 工作原理"></a>二. NFS 工作原理</h3><p><strong>实现原理</strong></p>
<p>首先存储服务器需要与客户端建立网络连接，之后实现挂载，此时数据存储到客户端挂载点目录时，实际上会通过网络传输存储到存储服务器对应的目录中。数据存储时属主和属组信息可能会发生变化，需要注意存储目录的权限。</p>
<p><strong>RPC 服务</strong></p>
<p>NFS 传输数据时使用的端口会随机选择，其中CentOS 5.x 的随机端口都小于 1024，而 CentOS 6.x 的随机端口都是较大的。NFS 客户端通过 RPC (中文意思是远程过程调用，英文 Remote Procedure Call 简称 RPC) 协议/服务来与服务端进行连接以此提供服务。</p>
<p>NFS 的 RPC 服务主要的功能就是记录每个 NFS 功能所对应的端口号，并且在 NFS 客户端请求时将该端口和功能对应的信息传递给请求数据的 NFS 客户端，从而确保客户端可以连接到正确的 NFS 端口上，达到实现数据传输交互的目的。</p>
<p>当 NFS 服务器端启动服务时会随机取用若干端口，并主动向 RPC 服务注册取用的相关端口及功能信息，RPC 服务就知道 NFS 每个端口对应的 NFS 功能了，然后 RPC 服务使用固定的 111 端口来监听 NFS 客户端提交的请求，并将正确的 NFS 端口信息回复给请求的 NFS客户端。</p>
<p>在启动 NFS Server 之前，首先要启动 RPC 服务 (Centos 5.8 下为 portmap 服务，Centos 6.6下为 rpcbind 服务)。如果 RPC 服务重新启动，原来已经注册好的 NFS 端口数据就会丢失，因此，此时 RPC 服务管理的 NFS 程序也需要重新启动以重新向 RPC 注册。</p>
<p>一般修改 NFS 配置文件后，是不需要重启 NFS 的，直接在命令行执行 <code>exportfs -rv</code> 即可使修改的 <code>/etc/exports</code> 生效。</p>
<p><strong>NFS 访问存取原理</strong></p>
<ol>
<li>首先用户访问网站程序，由程序在 NFS 客户端上发出存取 NFS 文件的请求，这时 NFS 客户端 (即执行程序的服务器) 的 RPC 服务 (rpcbind 服务) 就会通过网络向 NFS 服务器端的 RPC 服务 (rpcbind 服务) 的 111 端口发出 NFS 文件存取功能的询问请求。</li>
<li>NFS 服务器端的 RPC 服务 (rpcbind 服务) 找到对应的已注册的 NFS 端口后，通知 NFS客户端的 RPC 服务 (rpcbind 服务) 。</li>
<li>此时 NFS 客户端获取到正确的端口，并与 NFS daemon 联机存取数据。</li>
<li>NFS 客户端把数据存取成功后，返回给前端访问程序，告知用户存取结果，作为网站用户，就完成了一次存取操作。</li>
<li>总结：NFS 需要有 RPC 服务的协助才能成功对外提供服务。要使用 NFS 时，都需要首先启动 RPC 服务，NFS 服务必须在 RPC 服务启动之后启动，客户端无需启动 NFS 服务，但需要启动 RPC 服务。</li>
</ol>
<p><strong>NFS 服务常见进程详解</strong></p>
<p>运行 NFS 服务默认需要启动的服务或进程至少有：NFS quotas (rpc.rquotad) ，NFS daemon (nfsd) ，NFS mount (rpc.mountd) 。</p>
<p>NFS 服务的主要任务是共享文件系统数据，而文件系统数据的共享离不开权限问题。所以NFS 服务器启动时最少需要两个不同的进程，一个是管理 NFS 客户端是否能够登入的 rpc.nfsd 主进程，另一个用于管理 NFS 客户端是否能够取得对应权限的 rpc.mountd 进程。如果还需要管理磁盘配额，则 NFS 还要再加载 rpc.rquotad 进程。</p>
<h3 id="三-NFS-部署"><a href="#三-NFS-部署" class="headerlink" title="三. NFS 部署"></a>三. NFS 部署</h3><p><strong>服务端(172.16.1.31)部署过程：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 安装软件</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 创建用于存储的目录，同时调整属主属组信息</span></span><br><span class="line">mkdir /data</span><br><span class="line">chown nfsnobody. /data</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 补充，为了配置方便，可以先进行 hosts 配置</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line">172.16.1.7  web01 # 将其写入到 /etc/hosts 文件中</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 编写配置文件 /etc/exports ，默认为空，可以通过 man exports 来查看如何配置</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/data web01(rw,sync) backup(rw,sync) # 将其写入到 /etc/exports 文件中</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 启动服务</span></span><br><span class="line">systemctl start nfs.service</span><br></pre></td></tr></table></figure>

<p><strong>客户端(172.16.1.7)部署过程：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 安装软件(目的是让客户端识别 nfs 文件系统类型以实现挂载)</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 创建挂载点，进行本地目录挂载</span></span><br><span class="line">mkdir /upload</span><br><span class="line">mount -t nfs 172.16.1.31:/data /upload</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>

<p><strong>客户端挂载参数提升：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t nfs -o fg,hard,intr,rsize=131072,wsize=131072 10.0.0.7:/data /mnt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. <span class="built_in">fg</span> 代表客户端执行挂载时在前台执行，此时 mount 会持续尝试挂载直到成功或挂载时间超时</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. hard 使用 hard 模式挂载时，client 会一致尝试连接到 server，此时无法 umount 或者 <span class="built_in">kill</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 当使用 hard 挂载 timeout 时，如果指定 intr 参数可以在 timeout 后中断，避免出现问题时系统被 NFS 锁死</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. rsize 和 wsize 为性能参数，分别代表读出和写入的区块大小，可以提升传输能力。rsize 和 wsize 的大小最好是 1024 的倍数</span></span><br></pre></td></tr></table></figure>

<p><strong>客户端挂载参数优化 (mount 挂载优化内容)：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有关系统安全挂载参数选项</span></span><br><span class="line">mount -t nfs -o nosuid,noexec,nodev,rw 10.0.0.7:/data /mnt</span><br><span class="line"><span class="comment"># 禁止更新目录及文件时间戳挂载</span></span><br><span class="line">mount -t nfs -o noatime,nodiratime 10.0.0.7:/data /mnt</span><br><span class="line"><span class="comment"># 安全加优化的挂载方式</span></span><br><span class="line">mount -t nfs -o nosuid,noexec,nodev,noatime,nodiratime,rsize=131072,wsize=131072 10.0.0.7:/data /mnt</span><br></pre></td></tr></table></figure>

<h3 id="四-NFS-配置文件与配置参数详解"><a href="#四-NFS-配置文件与配置参数详解" class="headerlink" title="四. NFS 配置文件与配置参数详解"></a>四. NFS 配置文件与配置参数详解</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> NFS 默认配置文件路径为 /etc/exports，内容为空，需要用户自行配置</span> </span><br><span class="line">man exports # 查看官方配置说明文档，内容见下</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> sample /etc/exports file</span></span><br><span class="line">/               master(rw) trusty(rw,no_root_squash)</span><br><span class="line">/projects       proj*.local.domain(rw)</span><br><span class="line">/usr            *.local.domain(ro) @trusted(rw)</span><br><span class="line">/home/joe       pc001(rw,all_squash,anonuid=150,anongid=100)</span><br><span class="line">/pub            *(ro,insecure,all_squash)</span><br><span class="line">/srv/www        -sync,rw server @trusted @external(ro)</span><br><span class="line">/foo            2001:db8:9:e54::/64(rw) 192.0.2.0/24(rw)</span><br><span class="line">/build          buildhost[0-9].local.domain(rw)</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># 每一行分为三个部分</span></span><br><span class="line"><span class="comment"># 1. 指定本地存储数据的目录</span></span><br><span class="line"><span class="comment"># 2. 定义允许存储数据的主机信息，可以是ip地址、网段、主机名(需要提前进行 hosts 配置)</span></span><br><span class="line"><span class="comment"># 3. 存储服务参数配置，比较常用的有 rw、sync</span></span><br><span class="line"><span class="comment"># 总结：服务端存储目录 客户端主机1ip(参数) 客户端主机2ip(参数)</span></span><br></pre></td></tr></table></figure>

<p>关于 no_all_squash 的说明：假设客户端使用 linus 进行管理，如果存储服务器上不存在 linus 用户，则在存储服务器上 linus 的数据使用 linus 的 uid 和 gid 进行管理；如果存储服务器上虽然没有 linus 用户，但是存在 uid 与linus 一样的用户 zeus，那么 linus 的数据在存储服务器上使用 zeus 进行管理。</p>
<p><strong>参数配置图解说明如下</strong></p>
<p><img src="https://zeuslb.github.io/img/NFS%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%94%A8%E6%88%B7%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86%E5%9B%BE.svg" alt="NFS客户端用户映射原理图"></p>
<p><strong>NFS 客户端地址的配置详细说明见下</strong></p>
<table>
<thead>
<tr>
<th>客户端地址</th>
<th>具体地址</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>授权单一客户端访问 NFS</td>
<td>10.0.0.30</td>
<td>一般情况，生产环境中此配置不多</td>
</tr>
<tr>
<td>授权整个网段可访问 NFS</td>
<td>10.0.0.0/24</td>
<td>其中的 24 等同于 255.255.255.0，指定网段为生产环境中最常见的配置。配置简单，维护方便</td>
</tr>
<tr>
<td>授权整个网段可访问 NFS</td>
<td>10.0.0.*</td>
<td>指定网段的另外写法 (不推荐使用）</td>
</tr>
<tr>
<td>授权某个域名客户端访问</td>
<td>nfs.linus.com</td>
<td>此方法生产环境中一般情况不常用</td>
</tr>
<tr>
<td>授权整个域名客户端访问</td>
<td>*.linus.com</td>
<td>此方法生产环境中一般情况不常用</td>
</tr>
</tbody></table>
<p><strong>NFS 配置参数权限说明见下：</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>rw (常用)</td>
<td>指定存储目录具有读写权限</td>
</tr>
<tr>
<td>ro</td>
<td>指定存储目录具有只读权限，应用场景：对于开发人员管理的服务器 (一般为测试服务器) 进行挂载操作时设置 ro 权限</td>
</tr>
<tr>
<td>sync (常用)</td>
<td>数据同步传输，会将数据直接存储到 nfs 服务器的磁盘上 (针对中小型实际 NFS 应用场景，推荐)</td>
</tr>
<tr>
<td>async</td>
<td>数据异步传输，会将数据先存储到 nfs 服务器的内存中，之后定时定量地写入到磁盘上，存在安全问题</td>
</tr>
<tr>
<td>all_squash</td>
<td>将所有用户生成的数据转换为虚拟用户 nfsnobody (uid 和 gid 默认为 65534) 进行管理</td>
</tr>
<tr>
<td>no_all_squash (默认)</td>
<td>不对所有用户生成的数据进行属主和属组的转换</td>
</tr>
<tr>
<td>root_squash (默认)</td>
<td>将 root 用户生成的数据转换为虚拟用户 nfsnobody 进行管理</td>
</tr>
<tr>
<td>no_root_squash</td>
<td>不对 root 用户生成的数据进行属主和属组的转换</td>
</tr>
<tr>
<td>anonuid</td>
<td>将权限压缩为指定 uid 用户的权限，使用时在配置参数中指定 anonuid=888</td>
</tr>
<tr>
<td>anongid</td>
<td>将权限压缩为指定 gid 用户的权限，使用时在配置参数中指定 anongid=888</td>
</tr>
</tbody></table>
<p>配置好 NFS 服务后，通过 <code>cat /var/lib/nfs/etab</code> 命令可以看到 NFS 配置的参数以及默认自带的参数。</p>
<h3 id="五-错误排查"><a href="#五-错误排查" class="headerlink" title="五. 错误排查"></a>五. 错误排查</h3><p><strong>配置文件错误排查</strong></p>
<p>使用 exportfs -rv 重新加载配置文件，如果发生错误即可显示出具体的错误信息。</p>
<p>如果挂载时出现 <code>access denied by server while mounting ...</code> 时，可能的错误是配置文件错误。</p>
<p><strong>rpcbind 错误排查</strong></p>
<p>客户端挂载无反应，可能出现的问题是 rpcbind 服务程序(远程过程调用程序)未启动(启动：systemctl start rpcbind)。当两台主机进行远程通讯时，必须的信息包括了ip地址和端口号，但是有些程序比如 nfs 会存在多端口、端口经常变化或者无端口的情况，这时可能会出现远程连接不上的问题。rpcbind 服务可以解决此问题，固定端口是 111，在进行远程时会进行统一管理进行连接。</p>
<p>如果出现 <code>RPC: Program not registered</code> 错误提示，一般是 RPC 服务和 NFS 的服务启动顺序错误，重启即可。</p>
<p>可以通过 rpcinfo -p localhost (服务端) 、rpcinfo -p 172.16.1.31 (客户端) 查看 NFS 服务是否在 RPC 上注册成功 (注册成功即 NFS 部署成功，且启动顺序无问题)。</p>
<p><strong>防火墙问题</strong></p>
<p>客户端执行 <code>showmount -e  172.16.1.31</code> 可以检查是否有可以挂载信息，如果遇到以下报错信息，大多数是因为防火墙问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@web ~]# showmount -e  172.16.1.31</span><br><span class="line">clnt_create: RPC: Port mapper failure - Unable to receive: errno 113 (No route to host)</span><br></pre></td></tr></table></figure>

<p><strong>卸载设备问题排查</strong></p>
<p>卸载挂载设备时显示 <code>device is busy</code> 时，有可能是当前目录就是挂载的 NFS 目录，也有可能是 NFS Server 挂了。对于第二种情况，只能采用 <code>umount -lf /mnt</code> (其中的参数-f 为强制卸载，参数-l 为懒惰的卸载) 进行强制卸载。</p>
<p><strong>其他错误排查</strong></p>
<p>客户端挂载错误，可能出现的问题是 hosts 配置错误，需要注意 hosts 配置更改后需要重新启动 nfs.service 服务。</p>
<h3 id="六-NFS-存储服务常见问题说明"><a href="#六-NFS-存储服务常见问题说明" class="headerlink" title="六. NFS 存储服务常见问题说明"></a>六. NFS 存储服务常见问题说明</h3><p><strong>自动挂载问题说明：</strong></p>
<p>因为临时挂载时，重启服务器会失效，所以需要实现自动挂载，配置如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/fstab</span><br><span class="line">172.16.1.31:/data /upload nfs default 0 0</span><br></pre></td></tr></table></figure>

<p>根据系统启动流程，fstab 文件是在网络服务启动之前进行加载的，之所以挂载成功，是因为网络服务启动之后，会自动启动一个叫作 <code>remote-fs.target</code> 的服务，该服务会重新扫描 fstab 文件进行挂载，从而实现网络存储服务的挂载。</p>
<p>自动挂载也可以使用将挂载命令放到 <code>/etc/rc.local</code> 文件中。其缺点是偶尔可能出现开机挂载不上的问题，在实际工作环境下，处理开机自启动配置，还要对是否挂载进行监控。</p>
<p><strong>共享目录挂载时很卡问题说明：</strong></p>
<p>NFS 服务端重启之后。立刻进行挂载会出现此问题，因为 NFS 自身重启的时候，拥有无敌的时间，默认是 90 秒；在无敌时间内，是不能对共享目录进行更改的操作。</p>
<p>可以在系统配置 <code>/etc/sysconfig/nfs</code> 中指定了无敌时间的配置参数 (不推荐)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NFSD_V4_GRACE=90</span><br><span class="line">NFSD_V4_LEASE=90</span><br><span class="line">NLM_GRACE_PERI0D=90</span><br></pre></td></tr></table></figure>

<p>服务程序建议尽量平滑重启，即使用 <code>reload</code>，而不是 restart 。</p>
<p><strong>出现文件句柄错误说明：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount.nfs: Stale file handle</span><br></pre></td></tr></table></figure>

<p>配置改变后，客户端没有进行卸载而是直接使用挂载点，解决方案为卸载后重新进行挂载即可。</p>
<p><strong>存储服务器中创建存储目录不要有父级与子级关系说明</strong></p>
<p>如果有父子关系出现，可能的现象有父级目录可以让子级目录所指定的主机进行挂载、父级目录设置权限参数会有集成关系等。</p>
<h3 id="七-更多参考资料"><a href="#七-更多参考资料" class="headerlink" title="七. 更多参考资料"></a>七. 更多参考资料</h3><ul>
<li><a href="http://www.citi.umich.edu/projects/nfsv4/linux/">http://www.citi.umich.edu/projects/nfsv4/linux/</a></li>
<li><a href="http://www.vanemery.com/Linux/NFSv4/NFSv4-no-rpcsec.html">http://www.vanemery.com/Linux/NFSv4/NFSv4-no-rpcsec.html</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-network-filesystems/">http://www.ibm.com/developerworks/cn/linux/l-network-filesystems/</a></li>
<li><a href="http://www.tldp.org/HOWTO/NFS-HOWTO/index.html">http://www.tldp.org/HOWTO/NFS-HOWTO/index.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>网络通讯与 HTTP</title>
    <url>/2020/12/16/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8E%20HTTP/</url>
    <content><![CDATA[<h3 id="一-网站服务通讯过程"><a href="#一-网站服务通讯过程" class="headerlink" title="一. 网站服务通讯过程"></a>一. 网站服务通讯过程</h3><p><strong>网站服务通讯过程原理(简易版)</strong></p>
<p>首先用户在浏览器中输入域名，然后会进行 DNS 解析。获取到 IP 地址后，客户端和服务端通过 TCP 三次握手建立连接，然后客户端发送请求，服务端进行响应，最后会经过四次挥手断开连接。</p>
<p><strong>网站服务通讯过程原理/HTTP 协议请求的工作流程(描述版)</strong></p>
<ol>
<li>终端用户在 Web 浏览器地址栏输入访问地址 <a href="http://www.baidu.com/">www.baidu.com</a> 。</li>
<li>Web 浏览器请求 DNS 服务器把域名 <a href="http://www.baidu.com/">www.baidu.com</a> 转换为 Web 服务器的 IP 地址。</li>
<li>Web 浏览器将端口号 (默认 80) 从访问地址 (URL) 中解析出来。</li>
<li>Web 浏览器通过解析后的 IP 地址及端口号与 Web 服务器之间建立一条 TCP 连接 (三次握手)。</li>
<li>建立 TCP 连接后，Web 浏览器向 Web 服务器发送一条 HTTP 请求报文。</li>
<li>Web 服务器响应并读取浏览器的请求信息，然后返回一条 HTTP 响应报文。</li>
<li>Web 服务器关闭 HTTP 连接，关闭 TCP 连接，Web 浏览器显示访问的网站内容到屏幕上。</li>
</ol>
<p><strong>Windows 主机查看 DNS 的相关方式</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 Windows 本地缓存的 DNS 解析记录</span></span><br><span class="line">ipconfig /displaydns</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除 Windows 本地缓存的 DNS 解析记录</span></span><br><span class="line">ipconfig /flushdns</span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows 系统下 hosts 域名解析记录的位置：C:\Windows\system32\drivers\etc\hosts</span></span><br></pre></td></tr></table></figure>

<h3 id="二-DNS-介绍"><a href="#二-DNS-介绍" class="headerlink" title="二. DNS 介绍"></a>二. DNS 介绍</h3><p><strong>DNS 概念与作用</strong></p>
<p>DNS，全称为 Domain Name System ，其主要作用是把网站域名解析为对应的 IP 地址。从域名到 IP 的解析过程，称作 A 记录，即 Address Record。除了 A 记录解析，DNS 还可以完成很多功能，例如：</p>
<ul>
<li>设置 CNAME 别名记录，这个别名解析功能常被 CDN 加速服务商应用。</li>
<li>设置 MX 邮件记录，这个 MX 记录功能，在购买或搭建邮件服务时会被用到。</li>
<li>设置 PTR 记录，反向解析，即把 IP 地址解析为对应的域名，和 A 记录的解析相反，此功能在邮件服务等业务中会用到。</li>
<li>…</li>
</ul>
<p>DNS 系统的架构类似于一颗倒挂着的树，顶点是根，用 <code>.</code> 来表示。DNS 进行域名解析时是从后往前进行解析的。</p>
<p><strong>DNS 解析流程</strong></p>
<ol>
<li>客户端用户在浏览器里输入 <a href="http://www.baidu.com/">www.baidu.com</a> 网站地址后回车，系统首先会查找系统本地的 DNS 缓存及 hosts 文件信息，确定是否存在 <a href="http://www.baidu.com/">www.baidu.com</a> 域名对应的 IP解析记录，如果有就直接获取到 IP 地址，然后去访问这个 IP 地址对应的 <a href="http://www.baidu.com/">www.baidu.com</a> 域名的服务器。一般第一次请求时，DNS 缓存是没有解析记录的，而 hosts 多为内部临时测试使用。</li>
<li>如果客户端本地 DNS 缓存及 hosts 文件没有 <a href="http://www.baidu.com/">www.baidu.com</a> 域名对应的解析记录，那么系统会把浏览器的解析请求发送给客户端本地设置的 DNS 服务器地址 (通常称此 DNS 为 LDNS，即 Local DNS) 解析，如果 LDNS 服务器的本地缓存有对应的解析记录就会直接返回 IP 地址给客户端，如果没有，则 LDNS 会负责继续请求其他的 DNS 服务器。</li>
<li>LDNS 从 DNS 系统的(“.”)根开始请求对 <a href="http://www.baidu.com/">www.baidu.com</a> 域名的解析，根 DNS 服务器在全球一共有 13 台，根服务器下面是没有 <a href="http://www.baidu.com/">www.baidu.com</a> 域名解析记录的，但是根下面有 <a href="http://www.baidu.com/">www.baidu.com</a> 对应的顶级域 .com 的解析记录，因此，根会把.com 对应的 DNS 服务器地址返回给 LDNS。</li>
<li>LDNS 获取到 .com 对应的 DNS 服务器地址后，就会去 .com 服务器请求 <a href="http://www.baidu.com/">www.baidu.com</a> 域名的解析，而 .com 服务器下面也没有 <a href="http://www.baidu.com/">www.baidu.com</a> 域名对应的解析记录，但是有 baidu.com 域名的解析记录，因此 .com 服务器会把 baidu.com 对应的 DNS 服务器地址返回给 LDNS。</li>
<li>同理，LDNS 获取到 baidu.com 对应的 DNS 服务器地址后，会去 baidu.com服务器请求对 <a href="http://www.baidu.com/">www.baidu.com</a> 域名的解析，baidu.com 域名对应的 DNS 服务器是该域名的授权 DNS 服务器，这个 DNS 服务器是企业购买域名时用于管理解析的服务器 (也可能是自建的授权 DNS 服务器) ，这个服务器会有与 <a href="http://www.baidu.com/">www.baidu.com</a> 对应的 IP 解析记录，如果此时没有，就表示企业的域名人员没有为 <a href="http://www.baidu.com/">www.baidu.com</a> 域名做解析，即网站还没架设好。</li>
<li>LDNS 把来自授权 DNS 服务器的与 <a href="http://www.baidu.com/">www.baidu.com</a> 对应的 IP 解析记录发给客户端浏览器，并且 LDNS 会在本地把域名和 IP 的对应解析记录缓存起来，以便下一次更快地返回相同解析请求的记录。至此，整个 DNS 的解析流程就完成了。</li>
</ol>
<h3 id="三-HTTP-协议"><a href="#三-HTTP-协议" class="headerlink" title="三. HTTP 协议"></a>三. HTTP 协议</h3><p><strong>HTTP 协议初识</strong></p>
<p>HTTP 协议，全称 HyperText Transfer Protocol，中文名为超文本传输协议。是互联网上常用的通信协议之一。它有很多的应用，但最流行的就是用于 Web 浏览器和 Web 服务器之间的通信，即 www 应用或称 Web 应用。</p>
<p>HTTP 协议属于 OSI 模型中的第七层应用层协议。</p>
<p>HTTP 协议的 www 服务应用的默认端口为 80，另外一个加密的 www 服务应用 HTTPS 的默认端口为 443，主要用于网银、支付等和钱相关的业务。</p>
<p><strong>HTTP 协议版本</strong></p>
<p>HTTP/0.9 是 HTTP 协议的第一个版本，仅适用于数据信息的简介交换，即仅文本传输。只接受 GET 这一种请求方式，且不支持请求头，由于不支持 POST 方式，大多数敏感信息无法交换，至此客户端无法向服务器传递过多信息。缺点是信息种类过于单一，无法满足需求，串行处理。</p>
<p>HTTP/1.0 支持 Cache、MIME、Method ，引入了 POST 和 HEAD 命令，在一定程度上提升了数据的传输安全，是一个典型的串行连接事务。1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后即断开 TCP 连接，即不支持 keepalive 。服务器不跟踪每个客户，也不记录过去的请求。缺点是串行处理，效率低下。</p>
<p>HTTP/1.1 是当前互联网主流的 HTTP 版本。引入了持久连接机制并被默认采用，且能更好地配合代理服务器工作，还支持管道方式同一连接下同时发送多个请求，以降低线路负载，提高传输速度。新增方法有 PUT、PATCH、OPTIONS、DELETE 。缺点是同一 TCP 连接里，所有通信按次序进行，服务器只能顺序处理回应，如果前面处理过慢，会有许多请求排队，造成队头阻塞 (Head-of-line blocking) 。</p>
<p>HTTP/2.0 的头信息和数据体都是二进制，称为头信息帧和数据帧。2.0 可以复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了”队头堵塞”，该双向的实时通信称为多工 (Multiplexing)。2.0 引入了头信息压缩机制 (header compression)，头信息使用 gzip 或 compress 压缩后再发送。2.0  也允许服务器未经请求，主动向客户端发送资源，即服务器推送 (server push) 。</p>
<p><strong>HTTP 请求方法</strong></p>
<p>在 HTTP 通信中，每个 HTTP 请求报文都包含一个方法，用以告诉 Web 服务器端需要执行哪些具体的动作。这些动作包括获取指定 Web 页面、提交内容到服务器、删除服务器上资源文件等。这些 HTTP 请求报文中包含的方法被称为 HTTP 请求方法。常见的 HTTP 请求方法见下：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">GET</td>
<td align="left">获取 URI 指定的信息。如果 URI 指定的是文件，则返回文件的内容；如果 URI 指定的是 CGI 程序，则返回该程序的输出数据</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">HEAD</td>
<td align="left">和 GET 基本相同。不过它只返回 HTTP 的消息头 (message header) ，而并不返回数据的内容。用于获取文件最后更新时间等属性信息</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">POST</td>
<td align="left">从客户端向服务器发送数据。一般用于发送表单中填写的数据、上传文件等情况下</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">PUT</td>
<td align="left">替换 URI 指定的服务器上的文件。如果 URI 指定的文件不存在，则创建该文件</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">DELETE</td>
<td align="left">删除 URI 指定的服务器上的文件</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">CONNECT</td>
<td align="left">使用代理传输加密消息时使用的方法</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">OPTIONS</td>
<td align="left">允许客户端查看服务器的性能或者用于通知或查询通信选项</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">TRACE</td>
<td align="left">将服务器收到的请求行和头部 (header) 直接返回给客户端。用于在使用代理的环境中检查改写请求的情况 (即多用于测试)</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">PATCH</td>
<td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新</td>
</tr>
</tbody></table>
<p><strong>HTTP 状态码</strong></p>
<p>HTTP 状态码 (HTTP Status Code) 是用来表示 Web 服务器响应 HTTP 请求状态的数字代码。每当 Web 客户端向 Web 服务器发送一个 HTTP 请求时，Web 服务器都会返回一个状态响应代码。这个状态码是一个三位数字代码，作用是告知 Web 客户端此次请求是否成功，或者是否要采取其他的动作方式。</p>
<p>常见的状态码分类见下：</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">分类描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1**</td>
<td align="left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="left">2**</td>
<td align="left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td align="left">3**</td>
<td align="left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="left">4**</td>
<td align="left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="left">5**</td>
<td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<p>状态码速查见下：</p>
<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="left"><code>200</code></td>
<td align="left">OK</td>
<td align="left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-Authoritative Information</td>
<td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left">重置内容。服务器处理成功，用户终端 (例如：浏览器) 应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端 (例如：浏览器) 选择</td>
</tr>
<tr>
<td align="left"><code>301</code></td>
<td align="left">Moved Permanently</td>
<td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="left"><code>302</code></td>
<td align="left">Found</td>
<td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">Not Modified</td>
<td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">Unused</td>
<td align="left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="left"><code>307</code></td>
<td align="left">Temporary Redirect</td>
<td align="left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">Bad Request</td>
<td align="left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">Unauthorized</td>
<td align="left">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left">保留，将来使用</td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">Forbidden</td>
<td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="left"><code>404</code></td>
<td align="left">Not Found</td>
<td align="left">服务器无法根据客户端的请求找到资源 (网页) 。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">Method Not Allowed</td>
<td align="left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">Request Time-out</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-URI Too Large</td>
<td align="left">请求的URI过长 (URI通常为网址) ，服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">Requested range not satisfiable</td>
<td align="left">客户端请求的范围无效</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed</td>
<td align="left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td align="left"><code>500</code></td>
<td align="left">Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">Not Implemented</td>
<td align="left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">Bad Gateway</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">Gateway Time-out</td>
<td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version not supported</td>
<td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<p><strong>生产场景常见的状态码及其对应的作用</strong></p>
<table>
<thead>
<tr>
<th>状态代码</th>
<th>详细描述说明</th>
</tr>
</thead>
<tbody><tr>
<td>200 - OK</td>
<td>服务器成功返回网页，这是成功的 HTTP 请求返回的标准状态码</td>
</tr>
<tr>
<td>301 - Moved Permanently</td>
<td>永久跳转，所请求的网页将永久跳转到被设定的新位置，例如：从 <code>zeus.com</code> 跳转到 <code>www.linus.com</code></td>
</tr>
<tr>
<td>403 - Forbidden</td>
<td>禁止访问，虽然这个请求是合法的，但是服务器端因为匹配了预先设置的规则而拒绝响应客户端的请求，此类问题一般为服务器或服务权限配置不当所致。Nginx 403 forbidden 多种原因及故障模拟重现 (<a href="https://blog.51cto.com/oldboy/1633952)%E3%80%81apache">https://blog.51cto.com/oldboy/1633952)、apache</a> 服务 Forbidden 403 问题精彩总结 (<a href="https://blog.51cto.com/oldboy/581383">https://blog.51cto.com/oldboy/581383</a>)</td>
</tr>
<tr>
<td>404 - Not Found</td>
<td>服务器找不到客户端请求的指定页面，可能是客户端请求了服务器上不存在的资源所致。</td>
</tr>
<tr>
<td>500 - Internal Server Error</td>
<td>内部服务器错误，服务器遇到了意料不到的情况，不能完成客户的请求。这是一个较为笼统的报错，一般为服务器的设置或内部程序问题导致。例如：SELinux 开启，而又没有为 HTTP 设置规则许可，客户端访问就是 500</td>
</tr>
<tr>
<td>502 - Bad Gateway</td>
<td>坏的网关，一般是代理服务器请求后端服务时，后端服务不可用或没有完成响应网关服务器。这通常为反向代理服务器下面的节点出问题所致。反向代理服务器无法与后面的 web 服务节点服务器建立联系</td>
</tr>
<tr>
<td>503 - Service Unavailable</td>
<td>服务当前不可用，可能是服务器超载或停机维护导致的，或者是反向代理服务器后面没有可以提供服务的节点</td>
</tr>
<tr>
<td>504 - Gateway Timeout</td>
<td>网关超时，一般是网关代理服务器请求后端服务时，后端服务没有在特定的时间内完成处理请求。多数是服务器过载导致没有在指定的时间内返回数据给前端代理服务器。</td>
</tr>
</tbody></table>
<p><strong>HTTP 请求报文结构</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 模拟发送请求，查看请求与响应数据包</span></span><br><span class="line">curl -v www.jd.com # 利用 curl 命令的-v 参数，查看访问网站请求与响应信息</span><br><span class="line">wget --debug www.baidu.com # 利用 wget 命令的--debug 参数，查看访问网站请求与响应信息</span><br></pre></td></tr></table></figure>

<p>从 Web 客户端发往 Web 服务器的 HTTP 报文，称为请求报文 (Request Message) 。HTTP 请求报文由请求行、请求头部 (header) 、空行和请求报文主体几个部分组成。</p>
<p>HTTP 请求报文格式说明见下：</p>
<table>
<thead>
<tr>
<th>报文格式</th>
<th>报文信息</th>
</tr>
</thead>
<tbody><tr>
<td>请求行</td>
<td>请求方法 URL 协议版本</td>
</tr>
<tr>
<td>请求头</td>
<td>格式 → 字段名 1 : 值 1 ，主要包含一些客户端的信息说明</td>
</tr>
<tr>
<td>空行</td>
<td>空白无内容，隔离上下行，说明请求头部结束</td>
</tr>
<tr>
<td>请求报文主体</td>
<td>GET 方法没有请求报文主体，POST 方法才有</td>
</tr>
</tbody></table>
<p>请求行：请求报文的第一行，用来说明客户端想要做什么。内容有请求方法字段、URL 字段和 HTTP 协议版本字段组成，它们之间用空格分隔。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<p>第一个部分为请求方法字段，常见的有 GET 和 POST 。</p>
<p>第二个部分为 URL 字段，当有具体的请求时会包含具体的请求信息，如果没有具体请求信息时，默认首页信息作响应，即 / 。</p>
<p>第三个部分为 HTTP 协议版本字段，此处可能为不同的版本，主要有 HTTP1.0、HTTP1.1、HTTP2.0 版本。</p>
<p>请求头：请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号 <code>:</code> 分隔。请求头部的作用是通过客户端把请求的相关信息告诉给服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept：image&#x2F;gif,image&#x2F;jpeg # 媒体类型</span><br><span class="line">Accept-Language：zh-cn # 语言类型</span><br><span class="line">Accept-Encoding：gzip,deflate # 支持压缩</span><br><span class="line">User-Agent：Mozilla&#x2F;4.0(compatible;MSIE6.0;Windows NT;...) # 客户端类型</span><br><span class="line">Host: https:&#x2F;&#x2F;zeuslb.github.io&#x2F; # 访问网站的目标地址</span><br></pre></td></tr></table></figure>

<p>最后一个请求头部信息之后是一个空行，通过发送回车符和换行符，通知 Web 服务器空行以下不会有请求头部的信息了。</p>
<p>请求报文主体包含了要发送给 Web 服务器的数据信息。请求报文主体不会应用于 HTTP 的 GET 命令方法，而是应用与 POST 方法。POST 方法适用于需要客户填写表单的场合。</p>
<p><strong>HTTP 响应数据包结构</strong></p>
<p>HTTP 响应报文由起始行、响应头部 (header) 、空行和相应报文主体这几个部分组成。</p>
<p>HTTP 响应报文格式说明见下：</p>
<table>
<thead>
<tr>
<th>报文格式</th>
<th>报文信息</th>
</tr>
</thead>
<tbody><tr>
<td>起始行</td>
<td>协议及版本号、数字状态码、状态信息</td>
</tr>
<tr>
<td>响应头部</td>
<td>字段名 1：值 1</td>
</tr>
<tr>
<td>空行</td>
<td>空白无内容，隔离上下文，说明响应头部结束</td>
</tr>
<tr>
<td>响应报文主体</td>
<td>请求后服务端响应返回的数据</td>
</tr>
</tbody></table>
<p>起始行：相应报文的起始行也叫状态行，用来说明服务器响应客户端请求的状况。一般为协议及版本号、数字状态码、状态情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>

<p>响应头部：和请求报文类似，起始行的后面一般有若干个头部字段。每个头部字段都包含一个名字和一个值，两者之间用冒号分隔，头部结尾也是一个空行结束的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Server: Tengine # 告知客户端服务端使用web程序</span><br><span class="line">Content-Type: text/html # 文档的 MIME 类型</span><br><span class="line">Content-Length: 154 # 响应数据的字节大小</span><br><span class="line">Connection: keep-alive # 使用 TCP 长链接方式进行通讯</span><br><span class="line">Date: Tue, 15 Dec 2020 01:46:59 GMT # 日期</span><br><span class="line">Location: https://zeuslb.github.io/ # 指定跳转后的地址信息</span><br></pre></td></tr></table></figure>

<p>最后一个响应头部信息之后是一个空行，通过发送回车符和换行符，通知客户端空行下文无头部信息了。</p>
<p>响应报文主体：响应报文主体中装载了要返回给客户端的数据。这些数据可以是文本，也可以是二进制的 (如图<br>片、视频) 。</p>
<h3 id="四-网站服务资源类型介绍"><a href="#四-网站服务资源类型介绍" class="headerlink" title="四. 网站服务资源类型介绍"></a>四. 网站服务资源类型介绍</h3><p><strong>媒体资源</strong></p>
<p>互联网上的数据有很多不同的类型，Web 服务器会把通过 Web 传输的每个对象都打上 MIME 类型 (即 MIMEtype) 的数据格式标签。最初设计 MIME (Multipurpose Internet Mail Extension，多用途因特网邮件扩展) 是为了解决在不同的电子邮件系统之间搬移报文时存在的问题。后来 HTTP 也支持了这个功能，用它来描述数据并标记不同的数据内容类型。</p>
<p>当 Web 服务器响应 HTTP 请求时，会为每一个 HTTP 对象数据加一个 MIME 类型，当 Web 浏览器获取到服务器返回的对象时，会去查看相关的 MIME 类型，并进行相应处理。</p>
<p>MIME 类型存在与 HTTP 响应报文的响应头部信息里，它是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分割。生产场景最常见的 MIME 类型见下：</p>
<table>
<thead>
<tr>
<th>MIME 类型</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td>text/html</td>
<td>html、htm、shtml 文本类型</td>
</tr>
<tr>
<td>text/css</td>
<td>css 文本类型</td>
</tr>
<tr>
<td>text/xml</td>
<td>xml 文本类型</td>
</tr>
<tr>
<td>image/gif</td>
<td>gif 图像类型</td>
</tr>
<tr>
<td>image/jpeg</td>
<td>jpeg、jpg 图像类型</td>
</tr>
<tr>
<td>application/javascripts</td>
<td>js 文本类型</td>
</tr>
<tr>
<td>text/plain</td>
<td>txt 文本类型</td>
</tr>
<tr>
<td>application/json</td>
<td>json 文本类型</td>
</tr>
<tr>
<td>video/mp4</td>
<td>mp4 视频类型</td>
</tr>
<tr>
<td>video/quicktime</td>
<td>mov 视频类型</td>
</tr>
<tr>
<td>video/x-flv</td>
<td>flv 视频类型</td>
</tr>
<tr>
<td>video/x-ms-wmv</td>
<td>wmv 视频类型</td>
</tr>
<tr>
<td>video/x-msvideo</td>
<td>avi 视频类型</td>
</tr>
</tbody></table>
<p>可以在 Nginx 配置文件 mime.types 中查看支持的媒体类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">less /etc/nginx/mime.types</span><br></pre></td></tr></table></figure>

<p><strong>静态网页资源</strong></p>
<p>静态网页是相对于动态网页而言的，是指没有后台数据库、不含程序 (如 PHP、JSP、ASP) 、不可交互的网页。</p>
<p>静态网页资源的特点是：开发者编写的是什么，它显示的就是什么，一旦编写完成，就不会有任何改变。静态网页的维护和更新相对比较麻烦，每个不同的网页都需要单独编辑更新，静态网页一般适用于更新较少的宣传展示型网站。</p>
<p>静态网页资源的对应程序及资源文件的常见扩展名为：</p>
<ul>
<li>纯文本类程序或文件，如 .html、.htm、.xml、.shtml、.js、.css 等。</li>
<li>图片类文件或数据文档，如 .jpg、.gif、.png、.bmp、.txt、.doc、.ppt 等。</li>
<li>视频类流媒体文件，如 .mp4、.swf、.avi、.wmv、.flv 等。</li>
</ul>
<p>静态的网页的优点是网页内容是固定不变的，容易被搜索引擎收录，且网页程序在用户浏览器端解析，由于服务器端不进行解析，并且不需要读取数据库，因此服务器端可以接受更多的并发访问。</p>
<p>静态网页的缺点是开发难度大，数据变化时维护相对比较困难，且静态网页的交互性差，在程序的功能实现方面有较大的限制，比如登录、在线交谈等功能的实现。</p>
<p><strong>静态网页的架构思想</strong></p>
<p>在高并发、高访问量的场景下做架构优化，涉及的关键环节就是把动态网页转成静态网页，而不是直接请求数据库和动态服务器，并且可以把静态内容推送到前端缓存 (或 CDN) 中提供服务，这样就可以提升用户体验，节约服务器和维护成本。</p>
<p><strong>动态网页资源</strong></p>
<p>所谓的动态网页是与静态网页相对而言的，一般在动态网页网址中会有标志性的符号比如 <code>&amp;</code> 或者 <code>?</code> 等。动态网页并不是独立存在于服务器上的网页文件，当用户请求服务器上的动态程序时，服务器解析这些程序并可能通过读取数据库来返回一个完整的网页内容。</p>
<p>动态网页中的 “?” 在搜索引擎的收录方面存在一定的问题，搜索引擎一般不会从一个网站的数据库中访问全部网页，或者出于技术等方面的考虑，搜索蜘蛛一般不会去抓取网址中 “?” 后面的内容，因此在企业通过搜索引擎进行推广时，需要针对采用动态网页的网站做一定的技术处理 (伪静态技术) ，以便适应搜索引擎的抓取要求。</p>
<p><strong>动态网页的架构思想</strong></p>
<p>一般来说，静态网页的性能效率是动态网页的 10-30 倍。且动态网站效率很差，并发能力也很低，在高并发场景中，应尽可能转换成静态网页提供服务。动态转静态几乎是所有高并发网站必备的架构方案思路，也是高级架构师的职责所在。<br>此外，动态转静态也是根据业务需求设计，例如，对于更新频繁的网站，如果设计不好就可能会产生数据不一致的情况，即用户看到的数据不是网站最新的内容，而是静态的内容。</p>
<p><strong>关于静态网页和动态网页的一点说明</strong></p>
<p>从前端开发的角度来说，静态网页是指不使用 HTML5/CSS3 动画效果 或者 js 交互的网页，动态网页是指使用了上述技术的网页。</p>
<p>从整体网站架构来看，静态网页/网站指的是不使用数据库等交互性软件实现的网站，而动态网站一般均包含数据库，且实现方式除了用 html 、css 、js 等技术实现基本的页面效果外，还用到了 php 、jsp 、python 等语言与后端服务器进行了交互。</p>
<p><strong>伪静态网页</strong></p>
<p>顾名思义，伪静态就是通过某些技术 (如 rewrite) 把动态网页的 URL 地址伪装成静态网页 URL 地址。从网站的 URL 地址看，伪静态表面上看起来是静态内容 (如地址结尾带 html) ，但这其实是通过 rewrite 规则实现的 URL 地址重写。改写后的 URL 地址规范、美观，有利于搜索引擎抓取，以及提升用户访问体验。</p>
<p>伪静态网页并不能提升网站的访问效率，从理论上说还会降低网站的性能，没有动态转静态网页效率高，不过，<br>对于一些并发不是很大的网站来说，或者是硬件资源充足的网站来说，伪静态还是一个不错的功能。</p>
<p><strong>拓展：生产 Web 架构优化实战方案</strong></p>
<p><a href="http://oldboy.blog.51cto.com/2561410/736710">http://oldboy.blog.51cto.com/2561410/736710</a></p>
<p><a href="https://edu.51cto.com/course/3093.html">https://edu.51cto.com/course/3093.html</a></p>
<h3 id="五-URI、URL、URN-初识"><a href="#五-URI、URL、URN-初识" class="headerlink" title="五. URI、URL、URN 初识"></a>五. URI、URL、URN 初识</h3><p><strong>URL</strong></p>
<p>URL，全称为 Uniform Resource Location，即统一资源定位符，是因特网上标准的资源唯一地址。</p>
<p>URL 的格式/组成为 <code>协议://主机ip地址或者域名[:端口号]/资源地址</code>，其中端口号可以省略，默认为 80 。</p>
<p><strong>URI</strong></p>
<p>URI，全称为 Uniform Resource Identifier，即统一资源标识符，是一个用于标识某一互联网资源名称的字符串。URL 是 URI 命名机制的一个子集。</p>
<p><strong>URN</strong></p>
<p>Uniform Resource Name，统一资源命名，是通过名字来标识资源，比如 <code>mailto:linus@gmail.com</code> 。</p>
<p><strong>URI、URL、URN 的区别</strong></p>
<p>URI 是以一种抽象的，高层次概念定义统一资源标识，而 URL 和 URN 则是具体的资源标识的方式。URL 和 URN 都是一种 URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto 就是 URN 的一种示例。</p>
<h3 id="六-网站服务访问度量方式"><a href="#六-网站服务访问度量方式" class="headerlink" title="六. 网站服务访问度量方式"></a>六. 网站服务访问度量方式</h3><p><strong>IP</strong></p>
<p>IP (独立 IP) ，即 Internet Protocol，这里指独立 IP 数，独立 IP 数是指不同 IP 地址的计算机访问网站时被计的总次数。一般一天内 (00:00-24:00) 相同 IP 地址的客户端访问网站页面只会被计一次，记录独立 IP 的时间可为一天或一个月，目前通用的标准为 “一天” 。</p>
<p>通过独立 IP 数度量网站访问量，和实际的访问情况不是很匹配。国内的企业、学校等多数是用 NAT 上网的，一个独立 IP 背后可能有数十上百个客户端访问。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在 Nginx 服务端通过日志文件模拟实现统计 ip</span></span><br><span class="line">awk &#x27;&#123;print $1&#125;&#x27; /var/log/nginx/access.log</span><br><span class="line">uniq xxx # 对上下内容进行去重，与 sort 结合使用即可实现去重</span><br><span class="line">awk &#x27;&#123;print $1&#125;&#x27; /var/log/nginx/access.log | sort | uniq -c # 去重显示每个重复次数</span><br><span class="line">awk &#x27;&#123;print $1&#125;&#x27; /var/log/nginx/access.log | sort | uniq | wc -l # 显示总的数量</span><br></pre></td></tr></table></figure>

<p>对 IP 的度量方法见下：</p>
<ul>
<li>分析所有 Web 服务器的访问日志信息，对 IP 地址段去重后计数</li>
<li>在网站的每一个 (所有) 页面结尾，嵌入 JS 等统计程序代码，待用户加载网页后，IP 即传给统计 IP 的服务器，这种方法一般被第三方统计公司或在企业内部开发日志分析程序时使用。</li>
<li>用第三方大家比较信任的统计工具，例如：谷歌的统计 (GA) 。</li>
</ul>
<p><strong>PV</strong></p>
<p>PV (访问量) 即 Page View，中文翻译为页面浏览，即页面浏览量或点击量，不管客户端是不是相同，也不管 IP 是不是相同，用户只要访问网站页面就会被计算 PV，一次计一个 PV。</p>
<p>PV 的具体度量方法就是从客户浏览器发出一个对 Web 服务器的请求 (Request) ，Web 服务器接到这个请求后，将该请求对应的网页 (Page) 发送给浏览器，这样就产生了一个 PV。这里有一个问题，就是只要这个请求发送给了浏览器，无论这个页面是否完全打开 (或下载完成) ，都会被计数 (1 次为 1 个 PV) ，一般为了防止用户快速刷 PV，很多网站会把 PV 的统计程序放在页面的最下面。</p>
<p>用 PV 衡量网站时，PV 数反映的是浏览某网站的页面数量，每刷新一次页面也算一次。因此，可以说 PV 数与来访用户的数量成正比，但 PV 数并不是真正的页面来访者数量，而是网站被访问的页面数量，因为一个来访者可能产生多个 PV。</p>
<p>一个来访者访问网站，可能产生若干 PV 数，但是独立 IP 数就只有 1 个，因此，如果对比一个网站的独立 IP 数和 PV 数，不难看出，PV 数一定会大于等于独立 IP 数，其比例视网站的业务而定，对于分类门户，可能会达到10:1，甚至更多。</p>
<p>对 PV 的度量方法见下：</p>
<ul>
<li>分析 Web 服务的访问日志 (需要排除 JS、CSS 及各种图片的日志信息) ，只计算 HTML、PHP 等页面数量。</li>
<li>在网站的每一个页面结尾，嵌入 JS 等统计程序代码，待用户加载网页后，访问数量即传给统计 PV 的服务器，这种方法一般被第三方统计公司或企业内部开发日志分析程序时使用。</li>
<li>用第三方大家比较信任的统计工具，例如：谷歌的统计 (GA) </li>
</ul>
<p><strong>UV</strong></p>
<p>UV (独立访客) 即 Unique Visitor，同一个客户端 (PC 或移动端) 访问网站被计为一个访客。一天 (00：00-24:00) 内相同的客户端访问同一个网站只计一次 UV。UV 一般是以客户端 Cookie 等技术作为统计依据的，实际统计会有误差。</p>
<p>考虑到一台客户端计算机可能会有多人使用，因此，UV (独立访客) 实际上并不一定是独立的自然人访问。</p>
<p>对 UV 的度量方法见下：</p>
<ul>
<li>通过客户端 HTTP 请求报文分析：如果这些请求满足一些共同特征，比如来自同一个 IP 地址，且浏览器版本和操作系统版本相同，请求时间又相近等，那么就可以认为这些请求是来自于同一个客户端，那么多个页面访问也只算一个 UV。共同特征的定义是由服务器方决定的。通常，用 IP 地址+其它特征共同来定义的情况较多。但此种度量方法无法解决以下问题，例如：多个人的计算机软硬件雷同，并且是一个公司或学校的人；多个人共用一个计算机等情况。</li>
<li>通过 Cookie 鉴别：当客户端第一次访问某个网站服务器时，网站服务器会给这个客户端的计算机发出一个 Cookie，通常放在这个客户端计算机的 C 盘当中。在这个 Cookie 中会分配一个独一无二的编号，这其中会记录一些访问服务器的信息，如访问时间、访问了哪些页面等等。当你下次再访问这个服务器的时候，服务器就可以直接从你的计算机中找到上一次放进去的 Cookie 文件，并且对其进行一些更新，但那个独一无二的编号是不会变的。如果在一定时间内，服务器发现 2 个来访者对应的是一个编号，那么自然可以认为它来源于同一个来访者，于是就计算 1 个 UV。使用 Cookie 也存在一些问题，比如：有的客户端为保证更高级别的安全，关闭了 Cookie 的功能；或者是有些客户端设置了在退出页面时自动删除 Cookie，抑或你经常自己去手动删除 Cookie，那么这个方法就不那么精确了。</li>
</ul>
<p><strong>工作中用到的统计工具软件</strong></p>
<ul>
<li>网页信息统计软件-piwik<ul>
<li>pwiki 统计工具：<a href="https://matomo.org/">https://matomo.org/</a></li>
<li>pwiki 演示页面：<a href="https://piwik.org/demo">https://piwik.org/demo</a></li>
</ul>
</li>
<li>ELK 软件的使用：参考博文 <a href="http://blog.oldboyedu.com/elk/">http://blog.oldboyedu.com/elk/</a></li>
</ul>
<p><strong>并发</strong></p>
<p>并发，即网站服务器在单位时间内能够处理的最大连接数。</p>
<p>QPS (Query Per Second，每秒查询率) ：每秒查询率 QPS 是用于衡量一个特定的查询服务器在规定时间内所处理流量多少的标准。运维工作中，DNS 系统及数据库等服务的查询性能经常用每秒查询率来衡量。</p>
<p>IOPS (Input/Output Operations Per Sercond) ：IOPS 即每秒进行读写 (I/O) 操作的次数，多用于数据库等场合，衡量随机访问的性能。存储端的 IOPS 性能和主机端的 I/O 是不同的，IOPS 是指存储每秒可接受多少次主机发出的访问，主机的一次 I/O 需要多次访问存储才可以完成。</p>
<h3 id="七-网站服务初识"><a href="#七-网站服务初识" class="headerlink" title="七. 网站服务初识"></a>七. 网站服务初识</h3><p><strong>当前互联网主流 Web 服务软件</strong></p>
<ul>
<li>常用来提供静态 Web 服务的软件有如下三种：<ul>
<li>Apache：这是中小型 Web 服务的主流，Web 服务器中的老大哥。</li>
<li>Nginx：大型网站 Web 服务的主流，曾经 Web 服务器中的初生牛犊，现已长大。Nginx 的分支 Tengine (<a href="http://tengine.taobao.org/">http://tengine.taobao.org/</a>) 目前也在飞速发展。</li>
<li>Lighttpd：这是一个不温不火的优秀 Web 软件，社区不活跃，静态解析效率很高。在 Nginx 流行前，它是大并发静态业务的首选，国内百度贴吧、豆瓣等众多网站都有 Lighttpd 奋斗的身影。</li>
</ul>
</li>
<li>常用来提供动态服务的软件：<ul>
<li>PHP (FastCGI) ：大中小型网站都会使用，动态网页语言 PHP 程序的解析容器。</li>
<li>Tomcat：中小企业动态 Web 服务主流，互联网 Java 容器主流 (如 jsp、do) 。</li>
<li>Resin：大型动态 Web 服务主流，互联网 Java 容器主流 (如 jsp、do) 。</li>
<li>IIS (Internet information services) ：微软 windows 下的 Web 服务软件 (如 asp、aspx) 。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>nginx 部署与实践(一)</title>
    <url>/2020/12/17/nginx%20%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%9E%E8%B7%B5(%E4%B8%80)/</url>
    <content><![CDATA[<h3 id="一-nginx-部署安装"><a href="#一-nginx-部署安装" class="headerlink" title="一. nginx 部署安装"></a>一. nginx 部署安装</h3><p><strong>服务器环境</strong></p>
<p>本文使用环境为 CentOS7 ，其他环境安装可以参考官方网站 <a href="http://nginx.org/en/linux_packages.html">http://nginx.org/en/linux_packages.html</a> 。</p>
<p><strong>部署方式一：官方源安装</strong></p>
<p>使用官方源安装的目录结构会比较标准，同时可以下载最新的稳定版。</p>
<ol>
<li><p>更新 yum 下载源(nginx 官方网站：nginx.org)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 官方参考 http://nginx.org/en/linux_packages.html<span class="comment">#RHEL-CentOS</span></span></span><br><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载安装软件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y nginx</span><br><span class="line">nginx -V</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>部署方式二：编译安装</strong></p>
<ol>
<li><p>解决依赖问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y pcre-devel openssl-devel</span><br><span class="line"><span class="meta">#</span><span class="bash"> pcre-devel 可以实现兼容 perl 语言的正则表达式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> openssl-devel 可以实现基于 HTTPS 协议的数据传输</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建服务进程管理用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd nginx -M -s /sbin/nologin</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载编译安装源码包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.18.0.tar.gz</span><br><span class="line">tar xf nginx-1.18.0.tar.gz</span><br><span class="line">cd nginx-1.18.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译安装</p>
<ul>
<li><p>配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --help</span><br><span class="line"><span class="meta">#</span><span class="bash"> 常见参数说明</span></span><br><span class="line">--prefix=PATH # 指定软件程序的安装路径 /app/nginx-1.18.0</span><br><span class="line">--sbin-path=PATH # 软件有关命令文件的保存路径 /usr/bin</span><br><span class="line">--modules-path=PATH # 软件生成的模块保存路径</span><br><span class="line">--conf-PATH # 软件配置文件保存路径</span><br><span class="line">--error</span><br><span class="line">--with-xxx # 可以使用的功能模块</span><br><span class="line">--without-xxx # 指定不使用的功能模块</span><br><span class="line">./configure  --prefix=/app/nginx-1.18 --user=nginx --group=nginx  --with-http_ssl_module  --with-http_stub_status_module</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>nginx 部署与实践(二)</title>
    <url>/2020/12/18/nginx%20%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%9E%E8%B7%B5(%E4%BA%8C)/</url>
    <content><![CDATA[<h3 id="二-nginx-基础知识储备"><a href="#二-nginx-基础知识储备" class="headerlink" title="二. nginx 基础知识储备"></a>二. nginx 基础知识储备</h3><p><strong>第一篇</strong></p>
<p><a href="https://mubu.com/doc/28hp-jWbLAX">https://mubu.com/doc/28hp-jWbLAX</a></p>
<p><strong>第二篇</strong></p>
<p><a href="https://mubu.com/doc/7khpen43CQX">https://mubu.com/doc/7khpen43CQX</a></p>
<p><strong>第三篇</strong></p>
<p><a href="https://mubu.com/doc/jzrBripGQX">https://mubu.com/doc/jzrBripGQX</a></p>
<p><strong>第四篇</strong></p>
<p><a href="https://mubu.com/doc/3UToHNi5IQX">https://mubu.com/doc/3UToHNi5IQX</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>nginx 部署与实践(三)</title>
    <url>/2020/12/19/nginx%20%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%9E%E8%B7%B5(%E4%B8%89)/</url>
    <content><![CDATA[<h3 id="三-实践01：一个-nginx-服务器上部署多个网站"><a href="#三-实践01：一个-nginx-服务器上部署多个网站" class="headerlink" title="三. 实践01：一个 nginx 服务器上部署多个网站"></a>三. 实践01：一个 nginx 服务器上部署多个网站</h3><p><strong>基本环境</strong></p>
<p>CentOS 7.6.1810，服务器 ip 为 10.0.0.7 。</p>
<p>Windows10，VMnet8 ip 为 10.0.0.1 。</p>
<p>nginx/1.18.0</p>
<p><strong>需求</strong></p>
<p>部署两个网站，分别为：</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>域名</th>
<th>网站目录</th>
</tr>
</thead>
<tbody><tr>
<td>80</td>
<td><a href="http://www.linus.cc/">www.linus.cc</a></td>
<td>/html/linus</td>
</tr>
<tr>
<td>80</td>
<td><a href="http://www.zeus.cc/">www.zeus.cc</a></td>
<td>/html/zeus</td>
</tr>
</tbody></table>
<p><strong>实践</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 创建相应的网站目录</span><br><span class="line">[root@web01 ~]# mkdir -p &#x2F;html&#x2F;&#123;linus,zeus&#125;</span><br><span class="line"></span><br><span class="line"># 2. 上传对应的网站代码(此处仅模拟创建文件)</span><br><span class="line">[root@web01 ~]# echo &quot;this is linus&#39;s website&quot; &gt; &#x2F;html&#x2F;linus&#x2F;index.html</span><br><span class="line">[root@web01 ~]# echo &quot;this is zeus&#39;s website&quot; &gt; &#x2F;html&#x2F;zeus&#x2F;index.html</span><br><span class="line"></span><br><span class="line"># 3. 配置扩展配置文件</span><br><span class="line">[root@web01 ~]# mv &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf.bak # 该文件仅作为模板使用，不需要加载</span><br><span class="line">[root@web01 ~]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;linus.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80; # 配置端口</span><br><span class="line">    server_name  www.linus.cc; # 配置域名</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;html&#x2F;linus; # 配置站点目录</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@web01 ~]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;zeus.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.zeus.cc;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;html&#x2F;zeus;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 4. 查看主配置文件是否引用了刚才编写的两个扩展配置文件</span><br><span class="line">[root@web01 ~]# cat &#x2F;etc&#x2F;nginx&#x2F;nginx.conf </span><br><span class="line"># 有 include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf; 信息，确认包括了扩展配置文件</span><br><span class="line"></span><br><span class="line"># 5. 配置 windows 的 hosts 文件做本地 ip 与域名的映射，默认路径为C:\Windows\System32\drivers\etc\hosts</span><br><span class="line">10.0.0.7 www.linus.cc www.zeus.cc</span><br><span class="line"></span><br><span class="line"># 6. 启动 nginx 服务</span><br><span class="line">[root@web01 ~]# nginx -t</span><br><span class="line">nginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful</span><br><span class="line">[root@web01 ~]# systemctl start nginx</span><br><span class="line"></span><br><span class="line"># 7. 打开浏览器输入网址验证</span><br><span class="line">www.linus.cc</span><br><span class="line">www.zeus.cc</span><br></pre></td></tr></table></figure>

<h3 id="四-实践02：对部署的多个网站配置不同的日志文件，且做日志切割"><a href="#四-实践02：对部署的多个网站配置不同的日志文件，且做日志切割" class="headerlink" title="四. 实践02：对部署的多个网站配置不同的日志文件，且做日志切割"></a>四. 实践02：对部署的多个网站配置不同的日志文件，且做日志切割</h3><p><strong>基本环境</strong></p>
<p>在实践一的基础上进行实践。</p>
<p><strong>需求</strong></p>
<table>
<thead>
<tr>
<th>网站</th>
<th>错误日志</th>
<th>运行日志</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://www.linus.cc/">www.linus.cc</a></td>
<td>/var/log/</td>
<td></td>
</tr>
<tr>
<td><a href="http://www.zeus.cc/">www.zeus.cc</a></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>实践</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 注释或删除主配置文件设置</span><br><span class="line">[root@web01 ~]# vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf </span><br><span class="line">#error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;</span><br><span class="line">#access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line"># 2. 修改对应站点的配置文件(提示：error_log 和 access_log 均可以放在 server 中)</span><br><span class="line">[root@web01 ~]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;linus.conf </span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;linus_error.log warn;</span><br><span class="line">access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;linus_access.log  main;</span><br><span class="line">[root@web01 ~]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;zeus.conf </span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;zeus_error.log warn;</span><br><span class="line">access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;zeus_access.log  main;</span><br><span class="line"></span><br><span class="line"># 3. 修改 nginx 默认的日志切割配置文件</span><br><span class="line">[root@web01 ~]# vim &#x2F;etc&#x2F;logrotate.d&#x2F;nginx</span><br><span class="line"># 添加 dateext 使其切割后以日期结尾</span><br><span class="line"># 查看配置文件为 &#x2F;var&#x2F;log&#x2F;nginx&#x2F;*.log &#123; .. &#125; ，即相应的日志文件默认都会进行切割</span><br><span class="line"></span><br><span class="line"># 4. 查看是否配置成功</span><br><span class="line">[root@web01 ~]# ll &#x2F;var&#x2F;log&#x2F;nginx&#x2F;</span><br><span class="line">total 16</span><br><span class="line">-rw-r----- 1 nginx adm  1851 Dec 18 17:12 access.log</span><br><span class="line">-rw-r----- 1 nginx adm  1049 Dec 18 17:31 error.log</span><br><span class="line">-rw-r--r-- 1 root  root  191 Dec 18 17:34 linus_access.log</span><br><span class="line">-rw-r--r-- 1 root  root    0 Dec 18 17:28 linus_error.log</span><br><span class="line">-rw-r--r-- 1 root  root  191 Dec 18 17:34 zeus_access.log</span><br><span class="line">-rw-r--r-- 1 root  root    0 Dec 18 17:28 zeus_error.log</span><br></pre></td></tr></table></figure>

<h3 id="五-实践03：实现数据共享的功能"><a href="#五-实践03：实现数据共享的功能" class="headerlink" title="五. 实践03：实现数据共享的功能"></a>五. 实践03：实现数据共享的功能</h3><p><strong>基本环境</strong></p>
<p>在实践二的基础上进行实践。</p>
<p><strong>需求</strong></p>
<p>将 <a href="http://www.linus.cc/">www.linus.cc</a> 网站设置为数据共享网站，所有人均可访问所有内容。</p>
<p><strong>实践</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 设置&#x2F;创建共享存储目录，此处使用网站主目录 &#x2F;html&#x2F;linus 作为共享目录</span><br><span class="line"></span><br><span class="line"># 2. 删除主目录的 index.html(配置的默认响应首页)，将共享数据上传</span><br><span class="line">[root@web01 ~]# rm -f &#x2F;html&#x2F;linus&#x2F;index.html</span><br><span class="line">[root@web01 ~]# mkdir &#x2F;html&#x2F;linus&#x2F;&#123;资料文件,图片文件,视频文件&#125; -p</span><br><span class="line">[root@web01 ~]# echo &quot;xxx&quot; &gt; &#x2F;html&#x2F;linus&#x2F;资料文件&#x2F;企业介绍.txt</span><br><span class="line"></span><br><span class="line"># 3. 修改对应站点的配置文件</span><br><span class="line">[root@web01 ~]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;linus.conf </span><br><span class="line">autoindex on; # 在 location &#123;&#125; 中添加，表示没有默认页面时以文件列表的形式展现站点目录</span><br><span class="line">charset utf-8; # 在 server &#123;&#125; 中添加，此处为设置字符编码</span><br><span class="line">[root@web01 ~]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;zeus.conf </span><br><span class="line">autoindex on; # 在 location &#123;&#125; 中添加</span><br><span class="line">charset utf-8; # 在 server &#123;&#125; 中添加</span><br><span class="line"></span><br><span class="line"># 4. 平滑重启 nginx 服务</span><br><span class="line">[root@web01 ~]# nginx -t</span><br><span class="line">nginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful</span><br><span class="line">[root@web01 ~]# nginx -s reload</span><br><span class="line"></span><br><span class="line"># 5. 打开网址进行验证</span><br></pre></td></tr></table></figure>

<h3 id="六-实践04：实现页面访问控制功能-目录访问限制"><a href="#六-实践04：实现页面访问控制功能-目录访问限制" class="headerlink" title="六. 实践04：实现页面访问控制功能(目录访问限制)"></a>六. 实践04：实现页面访问控制功能(目录访问限制)</h3><p><strong>基本环境</strong></p>
<p>在实践三的基础上进行实践。</p>
<p><strong>需求</strong></p>
<p>配置某个机密目录只能 10.0.0.1 访问，其他客户端地址均不能访问。</p>
<p><strong>实践</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 创建机密目录，上传机密文件</span><br><span class="line">[root@web01 ~]# mkdir &#x2F;html&#x2F;linus&#x2F;机密文件</span><br><span class="line">[root@web01 ~]# echo linus:12345 &gt; &#x2F;html&#x2F;linus&#x2F;机密文件&#x2F;密码.txt</span><br><span class="line"></span><br><span class="line"># 2. 修改对应站点的配置文件</span><br><span class="line">[root@web01 ~]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;linus.conf </span><br><span class="line">location &#x2F;机密文件&#x2F; &#123; # 该 location 为新建的，每个 location &#123;&#125; 都是独立的。将一些通用配置进行复制</span><br><span class="line">    root   &#x2F;html&#x2F;linus;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">    autoindex on;</span><br><span class="line">    allow 10.0.0.1; # 仅允许 10.0.0.1 访问</span><br><span class="line">    deny all; # 除了 allow 允许的，其他的均不允许访问</span><br><span class="line">&#125;</span><br><span class="line"># 可以将 location 通用的配置放到 server &#123;&#125; 中，但不是每一项都可以放在 server 中</span><br><span class="line"></span><br><span class="line"># 3. 平滑重启 nginx 服务</span><br><span class="line">[root@web01 ~]# nginx -t</span><br><span class="line">nginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful</span><br><span class="line">[root@web01 ~]# nginx -s reload</span><br><span class="line"></span><br><span class="line"># 4. 更改 VMnet8 的 ip 为 10.0.0.1 或 10.0.0.2 并打开网址进行验证</span><br></pre></td></tr></table></figure>

<h3 id="七-实践05：实现页面访问控制功能-文件类型限制"><a href="#七-实践05：实现页面访问控制功能-文件类型限制" class="headerlink" title="七. 实践05：实现页面访问控制功能(文件类型限制)"></a>七. 实践05：实现页面访问控制功能(文件类型限制)</h3><p><strong>基本环境</strong></p>
<p>在实践三的基础上进行实践。</p>
<p><strong>需求</strong></p>
<p>配置客户端访问站点时，均不能访问 .txt 文件。</p>
<p><strong>实践</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 创建非 .txt 结尾的文件用于测试</span><br><span class="line">echo &quot;this is a css document.&quot; &gt; &#x2F;html&#x2F;linus&#x2F;资料文件&#x2F;xxx.css</span><br><span class="line">echo &quot;this is a doc document.&quot; &gt; &#x2F;html&#x2F;linus&#x2F;资料文件&#x2F;xxx.doc</span><br><span class="line"></span><br><span class="line"># 2. 修改对应站点的配置文件</span><br><span class="line">[root@web01 ~]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;linus.conf </span><br><span class="line">location ~ \.(txt|doc)$ &#123; # 该 location 为新建的，此处 ~ 代表区分大小写匹配</span><br><span class="line">    root   &#x2F;html&#x2F;linus;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">    autoindex on;</span><br><span class="line">    deny all;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"># 3. 平滑重启 nginx 服务</span><br><span class="line">[root@web01 ~]# nginx -t</span><br><span class="line">nginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful</span><br><span class="line">[root@web01 ~]# nginx -s reload</span><br><span class="line"></span><br><span class="line"># 4. 打开网址进行验证</span><br></pre></td></tr></table></figure>

<h3 id="八-实践06：实现页面访问控制功能-用户认证功能"><a href="#八-实践06：实现页面访问控制功能-用户认证功能" class="headerlink" title="八. 实践06：实现页面访问控制功能(用户认证功能)"></a>八. 实践06：实现页面访问控制功能(用户认证功能)</h3><p><strong>基本环境</strong></p>
<p>在实践三的基础上进行实践。</p>
<p><strong>需求</strong></p>
<p>用户访问站点时需要进行密码认证。</p>
<p><strong>实践</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 下载工具包</span><br><span class="line">[root@web01 ~]# yum install -y httpd-tools</span><br><span class="line"></span><br><span class="line"># 2. 生成密码文件，添加用户</span><br><span class="line">[root@web01 ~]# htpasswd -cb &#x2F;etc&#x2F;nginx&#x2F;passwd.txt linus 12345</span><br><span class="line">Adding password for user linus</span><br><span class="line">[root@web01 ~]# htpasswd -b &#x2F;etc&#x2F;nginx&#x2F;passwd.txt zeus 12345</span><br><span class="line">Adding password for user zeus</span><br><span class="line"># -b 参数表示创建文件，使用免交互的方式添加用户</span><br><span class="line"># -B 参数表示删除用户</span><br><span class="line"># -c 参数表示创建新的密码文件，在添加时注意不要加此参数</span><br><span class="line"></span><br><span class="line"># 3. 修改对应站点的配置文件</span><br><span class="line">[root@web01 ~]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;linus.conf </span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">    root   &#x2F;html&#x2F;linus;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">    autoindex on;</span><br><span class="line">    auth_basic &quot;访问认证&quot;;</span><br><span class="line">    auth_basic_user_file &#x2F;etc&#x2F;nginx&#x2F;passwd.txt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 4. 平滑重启 nginx 服务</span><br><span class="line">[root@web01 ~]# nginx -t</span><br><span class="line">nginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful</span><br><span class="line">[root@web01 ~]# nginx -s reload</span><br><span class="line"></span><br><span class="line"># 5. 打开网址进行验证</span><br></pre></td></tr></table></figure>

<h3 id="九-实践07：开启-nginx-服务状态监测功能"><a href="#九-实践07：开启-nginx-服务状态监测功能" class="headerlink" title="九. 实践07：开启 nginx 服务状态监测功能"></a>九. 实践07：开启 nginx 服务状态监测功能</h3><p><strong>基本环境</strong></p>
<p>在实践三的基础上进行实践。</p>
<p><strong>需求</strong></p>
<p>开启 nginx 服务状态监测功能。</p>
<p><strong>实践</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 修改对应站点的配置文件</span><br><span class="line">[root@web01 ~]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;linus.conf </span><br><span class="line">location &#x2F;basic_status &#123;</span><br><span class="line">	stub_status; # 开启 nginx 服务状态监测功能</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 2. 平滑重启 nginx 服务</span><br><span class="line">[root@web01 ~]# nginx -t</span><br><span class="line">nginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful</span><br><span class="line">[root@web01 ~]# nginx -s reload</span><br><span class="line"></span><br><span class="line"># 3. 打开网址 http:&#x2F;&#x2F;www.linus.cc&#x2F;basic_status 进行验证</span><br><span class="line">Active connections: 2 </span><br><span class="line">server accepts handled requests</span><br><span class="line"> 28 28 89 </span><br><span class="line">Reading: 0 Writing: 1 Waiting: 1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>rsync 部署与实践</title>
    <url>/2020/12/14/rsync%20%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h3 id="一-备份服务"><a href="#一-备份服务" class="headerlink" title="一. 备份服务"></a>一. 备份服务</h3><p><strong>介绍</strong></p>
<p>主要用于备份服务器中重要的数据，例如系统配置文件、服务配置文件、服务日志文件(数据采集) …</p>
<p><strong>作用</strong></p>
<p>早期使用本地备份，目的是作为数据对比文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp /etc/hosts&#123;,.bak&#125; <span class="comment"># 编辑前进行本地备份处理</span></span><br><span class="line">diff /etc/hosts /etc/hosts.bak <span class="comment"># 不带颜色的文件对比(只显示不一样的部分)</span></span><br><span class="line">vimdiff /etc/hosts /etc/hosts.bak <span class="comment"># 带颜色的文件对比(全文显示)</span></span><br></pre></td></tr></table></figure>

<p>远程备份主要用于数据还原。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scp /etc/hosts 172.16.1.41:/backup <span class="comment"># 使用 ssh 远程备份文件(推送数据)</span></span><br><span class="line"><span class="comment"># 问题：无法实现文件的属性时间(总是备份时的时间)</span></span><br><span class="line">scp -p /etc/hosts 172.16.1.41:/backup <span class="comment"># 使用 ssh 远程备份文件，且保持文件属性</span></span><br><span class="line"><span class="comment"># 问题：无法实现备份目录</span></span><br><span class="line">scp -pr /etc 172.16.1.41:/backup <span class="comment"># 使用 ssh 远程备份目录</span></span><br><span class="line"><span class="comment"># 问题：如何实现恢复</span></span><br><span class="line">scp -p 172.16.1.41:/backup /etc/hosts <span class="comment"># 使用 ssh 远程恢复文件(拉取数据)</span></span><br><span class="line"><span class="comment"># 问题：使用 scp 时的痛点</span></span><br><span class="line"><span class="comment"># 1. 每次备份数据均需要输入密码 → 无法实现自动化</span></span><br><span class="line"><span class="comment"># 2. 备份数据时无法进行传输限制</span></span><br><span class="line"><span class="comment"># 3. 备份数据时不同用户需要进行权限调整</span></span><br></pre></td></tr></table></figure>

<h3 id="二-备份服务工作原理"><a href="#二-备份服务工作原理" class="headerlink" title="二. 备份服务工作原理"></a>二. 备份服务工作原理</h3><p><strong>数据传输备份原理 (rsync)</strong></p>
<p>图示</p>
<p><img src="https://zeuslb.github.io/img/rsync%E5%A4%87%E4%BB%BD%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="rsync备份原理图"></p>
<p>过程见下：</p>
<ul>
<li>通过TCP三次握手建立网络连接</li>
<li>进行身份验证。客户端发送用户密码信息，服务端对比用户文件验证合法性</li>
<li>数据传输后需要进行属主和属组的变化。客户端文件属性信息统一变为服务端指定的用户信息</li>
</ul>
<p><strong>数据增量备份原理 (rsync)</strong></p>
<p>原理：在数据远程传输之前需要进行数据比对</p>
<p>比对方式有以下两种：</p>
<ul>
<li><p>根据文件SHA/MD5算法进行比对(根据文件名称以及文件内容识别文件之间的区别)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">md5sum /etc/hosts</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据文件属性信息进行比对(根据权限、时间、大小信息等进行区别)</p>
</li>
</ul>
<p><strong>备份服务的方式</strong></p>
<ul>
<li><p>定时备份数据：编写好备份数据的脚本文件，将其放入到定时任务中即可</p>
</li>
<li><p>实时备份数据：先对目录数据变化进行监控，然后利用rsync将变化的数据进行备份</p>
</li>
</ul>
<h3 id="三-rsync-部署安装"><a href="#三-rsync-部署安装" class="headerlink" title="三. rsync 部署安装"></a>三. rsync 部署安装</h3><p><strong>服务端部署：</strong></p>
<ol>
<li><p>在备份服务器上安装rsync</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y rsync</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建管理备份目录以及数据的用户信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">useradd rsync -M -s /sbin/nologin</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建备份目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir /backup</span><br><span class="line">   chown rsync. /backup</span><br><span class="line">   ll /backup -d</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户列表文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;rsync_backup:linus&#x27;</span> &gt; /etc/rsync.password</span><br><span class="line">chmod 600 /etc/rsync.password</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑配置文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/rsyncd.conf</span><br><span class="line"></span><br><span class="line">uid = rsync</span><br><span class="line">gid = rsync</span><br><span class="line">port = 873</span><br><span class="line">fake super = yes</span><br><span class="line">use chroot = no</span><br><span class="line">max connections = 200</span><br><span class="line">timeout = 300</span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line">lock file = /var/run/rsync.lock</span><br><span class="line"><span class="built_in">log</span> file = /var/<span class="built_in">log</span>/rsyncd.log</span><br><span class="line">ignore errors</span><br><span class="line"><span class="built_in">read</span> only = <span class="literal">false</span></span><br><span class="line">list = <span class="literal">false</span></span><br><span class="line">hosts allow = 172.16.1.0/24</span><br><span class="line">hosts deny = 0.0.0.0/32</span><br><span class="line">auth users = rsync_backup</span><br><span class="line">secrets file = /etc/rsync.password</span><br><span class="line">[backup]</span><br><span class="line">comment = <span class="string">&quot;backup dir by oldboy&quot;</span></span><br><span class="line">path = /backup</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl start rsyncd</span><br><span class="line">ps -ef | grep <span class="string">&quot;rsync&quot;</span></span><br><span class="line">netstat -lntup | grep 873 <span class="comment"># 查看系统网络服务状态，可以用于查看某个服务是否开启了(该命令属于net-tools程序)，参数记忆为 -untpl</span></span><br><span class="line"><span class="comment"># -l 显示网络监听信息</span></span><br><span class="line"><span class="comment"># -n 端口信息以数字方式显示</span></span><br><span class="line"><span class="comment"># -t 显示TCP协议的信息</span></span><br><span class="line"><span class="comment"># -u 显示UDP协议的信息</span></span><br><span class="line"><span class="comment"># -p 显示服务对应的进程信息(PID/Program name)</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>客户端部署：</strong></p>
<ul>
<li><p>交互式实现数据传输</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rsync -avz /etc/hosts rsync_backup@172.16.1.41::backup <span class="comment"># rsync -avz 备份文件 用户名@备份服务器ip::模块名</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>免交互实现数据传输</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式一：使用文件的方式(在客户端操作)</span></span><br><span class="line"><span class="built_in">echo</span> linus &gt; /etc/rsync.password <span class="comment"># 在客户端创建密码文件</span></span><br><span class="line">chmod 600 /etc/rsync.password <span class="comment"># 更改权限</span></span><br><span class="line">rsync -avz /etc/hosts rsync_backup@172.16.1.41::backup --password-file=/etc/rsync.password</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二：使用环境变量的方式(在客户端操作)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export RSYNC_PASSWORD=linus&#x27;</span> &gt;&gt; /etc/profile <span class="comment"># export 指令的作用是将一个普通变量变为环境变量</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line">rsync -avz /etc/hosts rsync_backup@172.16.1.41::backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拓展： env 命令：输出所有的环境变量</span></span><br><span class="line">env | grep RSYNC_PASSWORD</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>rsync 方式与 scp 方式在进行文件传输时的区别</strong></p>
<ul>
<li>可以实现增量复制目录下面的数据</li>
<li>复制目录时，目录后面有无斜线是有区别的<ul>
<li>scp ：无论有无斜线均复制目录；有星号时复制目录下内容</li>
<li>rsync：无斜线时复制目录；有斜线时复制目录下内容</li>
</ul>
</li>
</ul>
<h3 id="四-rsync-配置文件"><a href="#四-rsync-配置文件" class="headerlink" title="四. rsync 配置文件"></a>四. rsync 配置文件</h3><p><strong>路径</strong></p>
<p><code>/etc/rsyncd.conf</code></p>
<p><strong>配置说明</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">uid = rsync <span class="comment"># 指定rsync服务备份目录或者数据信息管理的用户信息</span></span><br><span class="line">gid = rsync <span class="comment"># 指定rsync服务备份目录或者数据信息管理的用户组信息</span></span><br><span class="line">port = 873 <span class="comment"># 指定服务端口号，如果修改后客户端在使用时需要加参数 --port=xxx</span></span><br><span class="line">fake super = yes <span class="comment"># uid指令指定的用户可以伪装为管理员用户</span></span><br><span class="line">use chroot = no <span class="comment"># 提高数据备份安全性(前提：需要将备份目录权限与uid信息设置为root用户)</span></span><br><span class="line">max connections = 200 <span class="comment"># 设置最大连接数(客户端连接数量)→ 保证已有连接的传输效率</span></span><br><span class="line">timeout = 300 <span class="comment"># 设置闲置连接的会话超时时间(单位是秒)</span></span><br><span class="line">pid file = /var/run/rsyncd.pid <span class="comment"># 记录服务程序的pid文件(自动生成和删除，可以用来判断服务是否启动)，用于记录进程号码</span></span><br><span class="line">lock file = /var/run/rsync.lock <span class="comment"># 记录服务程序的锁文件</span></span><br><span class="line"><span class="built_in">log</span> file = /var/<span class="built_in">log</span>/rsyncd.log <span class="comment"># 日志文件</span></span><br><span class="line">ignore errors <span class="comment"># 忽略错误(尽量忽略简单的异常错误，提高传输的可靠性)</span></span><br><span class="line"><span class="built_in">read</span> only = <span class="literal">false</span> <span class="comment"># 指定备份数据的目录是否是只读的</span></span><br><span class="line">list = <span class="literal">false</span> <span class="comment"># 列表显示备份服务模块信息</span></span><br><span class="line">hosts allow = 172.16.1.0/24 <span class="comment"># 白名单(允许客户端主机地址进行访问)</span></span><br><span class="line">hosts deny = 0.0.0.0/32 <span class="comment"># 黑名单(拒绝客户端主机地址的访问)</span></span><br><span class="line">auth users = rsync_backup <span class="comment"># 指定可以进行认证的用户(该用户不需要在系统中存在，仅在服务中做认证使用)</span></span><br><span class="line">secrets file = /etc/rsync.password <span class="comment"># 用户密码文件(格式为：username:password，权限必须是600，属主和属组为root)</span></span><br><span class="line">[backup] <span class="comment"># 模块信息，下面的内容为局部配置信息</span></span><br><span class="line">comment = <span class="string">&quot;backup dir by oldboy&quot;</span> <span class="comment"># 模块注释说明</span></span><br><span class="line">path = /backup <span class="comment"># 指定模块对应的备份目录(建议模块名和备份路径名保持一致)</span></span><br></pre></td></tr></table></figure>

<h3 id="五-rsync-常见命令"><a href="#五-rsync-常见命令" class="headerlink" title="五. rsync 常见命令"></a>五. rsync 常见命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 语法格式一：rsync 可以实现数据本地备份，与 cp 一致</span></span><br><span class="line">rsync /etc/hosts /backup/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 语法格式二：rsync 可以实现数据远程备份，与 scp 一致</span></span><br><span class="line">rsync -avz /etc/hosts root@172.16.1.41:/tmp # 将本地数据推送到远程主机上</span><br><span class="line">rsync -avz root@172.16.1.41:/tmp/hosts /etc # 将远程数据拉取到本地主机上</span><br><span class="line"><span class="meta">#</span><span class="bash"> 语法格式三：基于守护进程的方式实现数据传输</span></span><br><span class="line">rsync -avz /etc/hosts rsync_backup@172.16.1.41::backup # 本地 → 远程</span><br><span class="line">rsync -avz /etc/hosts rsync://rsync_backup@172.16.1.41:888/backup # 本地 → 远程</span><br><span class="line">rsync -avz rsync_backup@172.16.1.41::backup/hosts /etc/ # 本地 → 远程</span><br><span class="line"><span class="meta">#</span><span class="bash"> 常用参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v → 显示传输的过程(定时任务中可以不需要该参数)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -z → 在传输时对文件做压缩处理</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -a → 等价于执行了 -rlptgoD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r → 可以递归传输数据(传输目录)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l → 可以复制软链接文件(仅复制快捷方式，无意义)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -L → 可以复制软链接指向的源文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p → 维持属性中的权限不改变</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t → 维持属性中的修改时间不改变</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -o → 维持属性中的属主不改变(仅对管理员用户生效，即配置文件中的uid和gid均需要调整为root，且fake super需要注释)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -g → 维持属性中的属组不改变</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -D → 传输设备文件时可以保持设备文件属性保持不变</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -P → 显示传输进度</span></span><br></pre></td></tr></table></figure>

<h3 id="六-rsync-的多模块配置"><a href="#六-rsync-的多模块配置" class="headerlink" title="六. rsync 的多模块配置"></a>六. rsync 的多模块配置</h3><p><strong>作用</strong></p>
<p>可以实现数据的分类存储</p>
<p><strong>配置方法</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端配置</span></span><br><span class="line"><span class="comment"># 1. 编写配置文件</span></span><br><span class="line">[oldgirl_backup]</span><br><span class="line">comment = <span class="string">&quot;backup dir by oldgirl&quot;</span></span><br><span class="line">path = /oldgirl_backup</span><br><span class="line">auth users = oldgirl_bak</span><br><span class="line">[oldboy_backup]</span><br><span class="line">comment = <span class="string">&quot;backup dir by oldboy&quot;</span></span><br><span class="line">path = /oldboy_backup</span><br><span class="line">auth users = oldboy_bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建备份目录</span></span><br><span class="line">mkdir /oldgirl_backup</span><br><span class="line">chown rsync. /oldgirl_backup</span><br><span class="line">mkdir /oldboy_backup</span><br><span class="line">chown rsync. /oldboy_backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 设置用户列表文件</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;oldgirl_bak:oldgirl\noldboy_bak:oldboy&quot;</span> &gt;&gt; /etc/rsync.password</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 重启服务</span></span><br><span class="line">systemctl restart rsyncd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端配置</span></span><br><span class="line"><span class="comment"># 1. 配置密码文件</span></span><br><span class="line"><span class="built_in">echo</span> oldgirl &gt; /etc/oldgirl_bak_rsync_password</span><br><span class="line">chmod 600 /etc/oldgirl_bak_rsync_password</span><br><span class="line"><span class="built_in">echo</span> oldboy &gt; /etc/oldboy_bak_rsync_password</span><br><span class="line">chmod 600 /etc/oldboy_bak_rsync_password</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">rsync -avz /etc/hosts oldboy_bak@172.16.1.41::oldboy_backup --password-file=/etc/oldboy_bak_rsync_password</span><br><span class="line">rsync -avz /etc/hosts oldgirl_bak@172.16.1.41::oldgirl_backup --password-file=/etc/oldgirl_bak_rsync_password</span><br><span class="line"></span><br><span class="line"><span class="comment"># 补充说明：单个模块实现多个目录分类管理</span></span><br><span class="line">rsync -avz /etc/hosts oldboy_bak@172.16.1.41::oldboy_backup/network <span class="comment"># 直接加上/network即可，不存在会自动创建</span></span><br><span class="line"><span class="comment"># 注意：只能创建单级目录，不能创建多级目录</span></span><br></pre></td></tr></table></figure>

<h3 id="七-rsync-的数据排除功能"><a href="#七-rsync-的数据排除功能" class="headerlink" title="七. rsync 的数据排除功能"></a>七. rsync 的数据排除功能</h3><p><strong>作用</strong></p>
<p>在备份目录时，需要将目录中的某些数据排除掉</p>
<p><strong>配置方法</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 环境准备</span></span><br><span class="line"><span class="built_in">cd</span> data</span><br><span class="line">mkdir &#123;a..c&#125;_dir</span><br><span class="line">touch &#123;a..c&#125;_dir/file&#123;01..03&#125;.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求：a_dir中的file01.txt不要备份</span></span><br><span class="line"><span class="comment"># 需要用到 --exclude 参数，排除多个的时候可以使用多次，注意需要使用相对路径</span></span><br><span class="line">rsync -avz /data/ oldgirl_bak@172.16.1.41::oldgirl_backup --exclude a_dir/file01.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求：a_file整个目录排除；b_dir中的file02.txt不要备份</span></span><br><span class="line"><span class="comment"># 需要用到 --exclude-from=xxx，文件里面使用相对路径</span></span><br><span class="line">touch /tmp/rsync_exclude.txt</span><br><span class="line">vim /tmp/rsync_exclude.txt</span><br><span class="line">rsync -avz /data/ oldgirl_bak@172.16.1.41::oldgirl_backup --exclude-from /tmp/rsync_exclude.txt</span><br></pre></td></tr></table></figure>

<h3 id="八-rsync-的安全访问控制"><a href="#八-rsync-的安全访问控制" class="headerlink" title="八. rsync 的安全访问控制"></a>八. rsync 的安全访问控制</h3><p><strong>作用</strong></p>
<p>显示可以与备份服务器进行网络通讯的主机</p>
<p><strong>配置方法</strong></p>
<p>设置白名单和黑名单</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需求一：只允许172.16.1.31主机进行数据备份</span></span><br><span class="line"><span class="comment"># 方法：只配置白名单，黑名单注释使其失效</span></span><br><span class="line">hosts allow = 172.16.1.31</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求二：仅172.16.1.31主机禁止数据备份</span></span><br><span class="line"><span class="comment"># 方法：只配置黑名单，白名单注释使其失效</span></span><br><span class="line">hosts deny = 172.16.1.31</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问控制策略：</span></span><br><span class="line"><span class="comment"># 1. 只有白名单，匹配白名单的放行，不匹配的阻止</span></span><br><span class="line"><span class="comment"># 2. 只有黑名单，匹配黑名单的阻止，不匹配的放行</span></span><br><span class="line"><span class="comment"># 3. 既有黑名单也有白名单，先匹配白名单，匹配的放行，不匹配的看黑名单。黑名单匹配的阻止，不匹配的放行</span></span><br><span class="line"><span class="comment"># 4. 既在黑名单又在白名单上，白名单优先</span></span><br></pre></td></tr></table></figure>

<p>访问控制策略图示</p>
<p><img src="https://zeuslb.github.io/img/rsync%E8%AE%BF%E9%97%AE%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E7%AD%96%E7%95%A5.png" alt="rsync访问黑白名单策略"></p>
<h3 id="九-rsync-的无差异同步"><a href="#九-rsync-的无差异同步" class="headerlink" title="九. rsync 的无差异同步"></a>九. rsync 的无差异同步</h3><p><strong>作用</strong></p>
<p>保证客户端数据与备份服务端的数据一致</p>
<p><strong>配置方法</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rsync -avz /data/ oldgirl_bak@172.16.1.41::oldgirl_backup --delete</span><br></pre></td></tr></table></figure>

<p><strong>企业应用</strong></p>
<p>保证线上服务端和线下服务端的数据一致性。慎用<code>--delete</code>，如果目录不正确，则会将备份服务器或者客户端的所有内容删除。</p>
<h3 id="十-rsync-的传输限速功能"><a href="#十-rsync-的传输限速功能" class="headerlink" title="十. rsync 的传输限速功能"></a>十. rsync 的传输限速功能</h3><p><strong>作用</strong></p>
<p>防止某个主机占用过多带宽导致其他服务器无法进行数据的传输</p>
<p><strong>配置方法</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">--bwlimit=100 <span class="comment"># 默认单位是kB/s</span></span><br></pre></td></tr></table></figure>

<h3 id="十一-rsync-的列表查询功能"><a href="#十一-rsync-的列表查询功能" class="headerlink" title="十一. rsync 的列表查询功能"></a>十一. rsync 的列表查询功能</h3><p><strong>配置方法</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端修改配置文件</span></span><br><span class="line">list = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端查看模块列表</span></span><br><span class="line">rsync 172.16.1.41:: </span><br></pre></td></tr></table></figure>

<h3 id="十三-rsync-备份服务项目实战"><a href="#十三-rsync-备份服务项目实战" class="headerlink" title="十三. rsync 备份服务项目实战"></a>十三. rsync 备份服务项目实战</h3><p><strong>项目实战方案规划</strong></p>
<ol>
<li><p>项目前言介绍(目前的痛点)</p>
</li>
<li><p>项目需求说明</p>
<blockquote>
<ol>
<li>所有服务器的备份目录必须都为 /backup</li>
<li>要备份的系统配置文件包括但不限于：</li>
</ol>
<ul>
<li>定时任务服务的配置文件(/var/spool/cron/root) → 适合web和nfs服务器</li>
<li>开机自启动的配置文件(/etc/rc.local) → 适合web和nfs服务器</li>
<li>日常脚本的目录(/server/scripts)</li>
<li>防火墙iptables的配置文件(/etc/sysconfig/iptables)</li>
</ul>
<ol start="3">
<li>Web服务器站点目录假定为/var/html/www/</li>
<li>Web服务器访问日志路径假定为/app/logs/</li>
<li>服务器保留打包后的7天的备份数据即可(本地留存不能多于7天，因为太多硬盘会满)</li>
<li>备份服务器上,保留每周一的所有数据副本，其它要保留6个月的数据副本。</li>
</ol>
<ul>
<li>方案一：对周一数据进行标记</li>
<li>方式二：备份服务器可以单独将周一数据提取出来</li>
</ul>
<ol start="7">
<li>备份服务器上,要按照备份数据服务器的内网IP为目录名称保存备份，备份的文件按照时间名字保存</li>
<li>需要确保备份的数据尽量完整正确，在备份服务器上对备份的数据进行检查，把备份的成功及失败结果信息发给系统管理员邮箱中</li>
</ol>
</blockquote>
</li>
<li><p>项目实施进度</p>
</li>
<li><p>项目实战部署</p>
</li>
<li><p>拓展：<code>md5sum -c check.txt</code> 的工作原理</p>
<ol>
<li>读取文件信息(读取到校验值和文件名)</li>
<li>根据文件内容查看数据信息</li>
<li>将读取文件的校验值与源check文件的校验值做对比</li>
</ol>
</li>
</ol>
<p><strong>项目实战实施部署</strong></p>
<ol>
<li><p>客户端部署(nfs01、web01)</p>
<ol>
<li><p>免交互传输数据功能：配置环境变量</p>
</li>
<li><p>编写脚本完成需求</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建脚本目录和脚本文件</span></span><br><span class="line">mkdir -p /server/scripts</span><br><span class="line">touch bachup_date.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑 backup_date.sh 脚本</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 初始化变量</span></span><br><span class="line">Eth1_ip=`ip a s eth1 | awk -F <span class="string">&quot;[ /]+&quot;</span> <span class="string">&#x27;NR==3&#123;print $3&#125;&#x27;</span>`</span><br><span class="line">Date_info=`date <span class="string">&quot;+%F_星期%w&quot;</span> -d <span class="string">&quot;-1 day&quot;</span>`</span><br><span class="line"><span class="comment"># 1. 创建本地备份目录(包括ip地址)</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d /backup ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	mkdir -p /backup/<span class="variable">$Eth1_ip</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 2. 打包备份数据到本地(注意软链接文件和时间问题)</span></span><br><span class="line">tar zcfh /backup/<span class="variable">$&#123;Eth1_ip&#125;</span>/system_backup_<span class="variable">$&#123;Date_info&#125;</span>.tar.gz /var/spool/cron/root /etc/rc.local /server/scripts /etc/sysconfig/iptables &amp;&gt; /dev/null</span><br><span class="line"><span class="comment"># 3. 清除七天前的历史备份数据</span></span><br><span class="line">find /backup/<span class="variable">$&#123;Eth1_ip&#125;</span>/ -<span class="built_in">type</span> f -name <span class="string">&quot;*.tar.gz&quot;</span> -mtime +7 -delete</span><br><span class="line"><span class="comment"># 4. 生成每天数据的校验文件</span></span><br><span class="line">find /backup/<span class="variable">$Eth1_ip</span>/ -mmin -10 -name <span class="string">&quot;*.tar.gz&quot;</span> | xargs md5sum &gt; /backup/<span class="variable">$Eth1_ip</span>/check.txt</span><br><span class="line"><span class="comment"># 5. 传输备份数据</span></span><br><span class="line">rsync -az /backup/<span class="variable">$Eth1_ip</span> linus@172.16.1.41::backup</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写定时任务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 * * * &#x2F;bin&#x2F;sh &#x2F;server&#x2F;scripts&#x2F;backup_data.sh &amp;&gt; &#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>服务端部署(backup)</p>
<ol>
<li><p>部署搭建 rsync 服务</p>
</li>
<li><p>对备份的数据做完整性校验</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建脚本目录和脚本文件</span></span><br><span class="line">mkdir -p /server/scripts</span><br><span class="line">touch bachup_date.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑 backup_date.sh 脚本</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 1. 校验数据完整性</span></span><br><span class="line">find /backup/ -<span class="built_in">type</span> f -name <span class="string">&quot;check.txt&quot;</span> | xargs mdssum -c &gt; /var/<span class="built_in">log</span>/backup.log</span><br><span class="line"><span class="comment"># 2. 发送邮件(校验结果信息)</span></span><br><span class="line">mail -s <span class="string">&quot;backup_check&quot;</span> 714616622@qq.com &lt; /var/<span class="built_in">log</span>/backup.log</span><br><span class="line"><span class="comment"># 3. 清理180天以前的数据</span></span><br><span class="line">find /backup/ -<span class="built_in">type</span> f -mtime +180 ! -name <span class="string">&quot;*_星期1.tar.gz&quot;</span> -delete</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">   <span class="comment"># 邮件配置</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 1. 编辑配置文件 /etc/maul.rc</span></span><br><span class="line"><span class="built_in">set</span> from=714616622@qq.com smtp=smtp.qq.com     <span class="comment"># 邮件发送邮件服务器域名</span></span><br><span class="line">   <span class="built_in">set</span> smtp-auth-user=714616622@qq.com smtp-auth-password=abftwbzzphewbeah smtp-auth=login</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 2. 重启服务</span></span><br><span class="line">   systemctl restart postfix.service</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 3. 测试邮件功能</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;xxx&quot;</span> | mail -s <span class="string">&quot;标题&quot;</span> lbrunnerboy@gmail.com</span><br></pre></td></tr></table></figure></li>
<li><p>编写定时任务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0 8 * * * /bin/sh /server/scripts/backup_server.sh &amp;&gt; /dev/null</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<p><strong>项目实施验收检查</strong></p>
<p><strong>项目实战(自己的代码)</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份服务器代码：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 数据完整性校验</span></span><br><span class="line">find /backup -<span class="built_in">type</span> f -name <span class="string">&quot;check.pw&quot;</span> | xargs md5sum -c &gt; /var/<span class="built_in">log</span>/Integrity_check</span><br><span class="line"><span class="comment"># 邮件发送</span></span><br><span class="line">mail -s <span class="string">&quot;备份数据结果&quot;</span> 446951558@qq.com &lt; /var/<span class="built_in">log</span>/Integrity_check</span><br><span class="line"><span class="comment"># 保留每周一的所有数据副本，其他保留6个月的数据副本</span></span><br><span class="line">find /backup -<span class="built_in">type</span> f ! -name <span class="string">&quot;*Monday.tar.gz&quot;</span> -mtime +180 -name -delete</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nfs 服务器代码：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line"><span class="built_in">export</span> RSYNC_PASSWORD=linus(定时任务无法识别环境变量)</span><br><span class="line">date_info=$(date <span class="string">&quot;+%F_%A&quot;</span> -d <span class="string">&quot;-1 day&quot;</span>) <span class="comment"># 备份时间信息</span></span><br><span class="line">bak_dir=<span class="string">&quot;/backup/<span class="subst">$(/usr/sbin/ip a s eth1 | awk -F <span class="string">&quot;[ /]+&quot;</span> &#x27;NR==3&#123;print $3&#125;&#x27;)</span>&quot;</span> <span class="comment"># 备份目标目录(后面不加/的原因是需要在rsync备份时将目录及其子文件传输)</span></span><br><span class="line">bak_system_data=<span class="string">&quot;/var/spool/cron/root /etc/rc.local /server/scripts /etc/sysconfig/iptables&quot;</span> <span class="comment"># 备份数据列表(系统文件)</span></span><br><span class="line">bak_web_code=<span class="string">&quot;/var/html/www&quot;</span> <span class="comment"># 备份数据列表(代码文件)</span></span><br><span class="line">bak_web_log=<span class="string">&quot;/app/logs&quot;</span> <span class="comment"># 备份数据列表(日志文件)</span></span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$bak_dir</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    mkdir -p <span class="variable">$bak_dir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 压缩数据</span></span><br><span class="line">tar zcfh <span class="variable">$bak_dir</span>/system_data_<span class="variable">$&#123;date_info&#125;</span>.tar.gz <span class="variable">$bak_system_data</span></span><br><span class="line"><span class="comment"># 删除七天前的数据</span></span><br><span class="line">find <span class="variable">$bak_dir</span> -<span class="built_in">type</span> f -name <span class="string">&quot;*.tar.gz&quot;</span> -mtime +7 -delete</span><br><span class="line"><span class="comment"># 数据校验</span></span><br><span class="line">find <span class="variable">$bak_dir</span> -<span class="built_in">type</span> f -name <span class="string">&quot;*.tar.gz&quot;</span> -mmin -200 | xargs md5sum &gt; <span class="variable">$bak_dir</span>/check.pw</span><br><span class="line"><span class="comment"># rsync 备份</span></span><br><span class="line">rsync -az <span class="variable">$bak_dir</span> linus@172.16.1.41::backup</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># web 服务器代码：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line"><span class="built_in">export</span> RSYNC_PASSWORD=linus</span><br><span class="line">date_info=$(date <span class="string">&quot;+%F_%A&quot;</span> -d <span class="string">&quot;-1 day&quot;</span>) <span class="comment"># 备份时间信息</span></span><br><span class="line">bak_dir=<span class="string">&quot;/backup/<span class="subst">$(/usr/sbin/ip a s eth1 | awk -F <span class="string">&quot;[ /]+&quot;</span> &#x27;NR==3&#123;print $3&#125;&#x27;)</span>&quot;</span> <span class="comment"># 备份目标目录(后面不加/的原因是需要在rsync备份时将目录及其子文件传输)</span></span><br><span class="line">bak_system_data=<span class="string">&quot;/var/spool/cron/root /etc/rc.local /server/scripts /etc/sysconfig/iptables&quot;</span> <span class="comment"># 备份数据列表(系统文件)</span></span><br><span class="line">bak_web_code=<span class="string">&quot;/var/html/www&quot;</span> <span class="comment"># 备份数据列表(代码文件)</span></span><br><span class="line">bak_web_log=<span class="string">&quot;/app/logs&quot;</span> <span class="comment"># 备份数据列表(日志文件)</span></span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$bak_dir</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    mkdir -p <span class="variable">$bak_dir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 压缩数据</span></span><br><span class="line">tar zcfh <span class="variable">$bak_dir</span>/system_data_<span class="variable">$&#123;date_info&#125;</span>.tar.gz <span class="variable">$bak_system_data</span></span><br><span class="line">tar zcfh <span class="variable">$bak_dir</span>/web_code_<span class="variable">$&#123;date_info&#125;</span>.tar.gz <span class="variable">$bak_web_code</span></span><br><span class="line">tar zcfh <span class="variable">$bak_dir</span>/web_log_<span class="variable">$&#123;date_info&#125;</span>.tar.gz <span class="variable">$bak_web_log</span> &amp;&gt; /dev/null</span><br><span class="line"><span class="comment"># 删除七天前的数据</span></span><br><span class="line">find <span class="variable">$bak_dir</span> -<span class="built_in">type</span> f -name <span class="string">&quot;*.tar.gz&quot;</span> -mtime +7 -delete</span><br><span class="line"><span class="comment"># 数据校验</span></span><br><span class="line">find <span class="variable">$bak_dir</span> -<span class="built_in">type</span> f -name <span class="string">&quot;*.tar.gz&quot;</span> -mmin -200 | xargs md5sum &gt; <span class="variable">$bak_dir</span>/check.pw</span><br><span class="line"><span class="comment"># rsync 备份</span></span><br><span class="line">rsync -az <span class="variable">$bak_dir</span> linus@172.16.1.41::backup</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 邮件配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 编辑配置文件 /etc/maul.rc</span></span><br><span class="line"><span class="built_in">set</span> from=714616622@qq.com <span class="comment"># 指定要连接访问邮箱服务</span></span><br><span class="line"><span class="built_in">set</span> smtp=smtp.qq.com     <span class="comment"># 邮件发送邮件服务器域名</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth-user=714616622@qq.com <span class="comment"># 邮箱账号信息</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth-password=abftwbzzphewbeah <span class="comment"># 邮箱密码信息</span></span><br><span class="line"><span class="built_in">set</span> smtp-auth=login <span class="comment"># 需要进行远程连接登录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 重启服务</span></span><br><span class="line">systemctl restart postfix.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 测试邮件功能</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;xxx&quot;</span> | mail -s <span class="string">&quot;标题&quot;</span> lbrunnerboy@gmail.com</span><br><span class="line">mail -s <span class="string">&quot;标题&quot;</span> lbrunnerboy@gmail.com &lt; /etc/mailcontent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拓展</span></span><br><span class="line">mailq <span class="comment"># 查看邮件发送队列</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拓展：如何获取ip地址</span></span><br><span class="line"><span class="comment"># 1. 先在 /etc/hosts 中配置好ip映射信息</span></span><br><span class="line"><span class="comment"># 2. 使用 hostname -i 即可获取到ip地址</span></span><br></pre></td></tr></table></figure>

<h3 id="十四-实时同步"><a href="#十四-实时同步" class="headerlink" title="十四. 实时同步"></a>十四. 实时同步</h3><p><strong>目的</strong></p>
<p>确保指定备份目录中数据产生变化时及时进行传输备份</p>
<p><strong>实时同步应用</strong></p>
<p>用户上传的数据信息，建议进行无差异实时同步(用户自己删除数据属于主观行为，企业服务器无特殊需求时无需备份用户数据)</p>
<p><strong>如何监控数据变化</strong></p>
<ol>
<li><p>工具：inotify-tools</p>
</li>
<li><p>目的：监控目录数据变化</p>
</li>
<li><p>部署：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 安装在客户端</span></span><br><span class="line">yum install -y inotify-tools</span><br><span class="line"><span class="comment"># 2. 利用命令监控数据变化</span></span><br><span class="line">inotifywait <span class="comment"># 监控目录中数据变化</span></span><br><span class="line">inotifywatch <span class="comment"># 统计目录中数据变化的数量</span></span><br><span class="line"><span class="comment"># 3. 语法</span></span><br><span class="line">inotifywait [OPTIONS] 目录</span><br><span class="line"><span class="comment"># 4. 常见参数</span></span><br><span class="line"><span class="comment"># @&lt;file&gt;     → 等价于 exclude-from=xxx，排除操作(多个)</span></span><br><span class="line"><span class="comment"># --exclude   → 排除某个目录或文件</span></span><br><span class="line"><span class="comment"># --excludei  → 排除某个目录或文件(文件或目录名不区分大小写)</span></span><br><span class="line"><span class="comment"># -m          → 持续监控，无该参数时只监控到一次事件就会退出</span></span><br><span class="line"><span class="comment"># -r          → 递归监控，即监控指定目录的同时监控各级子目录及其文件</span></span><br><span class="line"><span class="comment"># -q          → 只显示事件变化信息(不显示提示等无关紧要的信息)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -qq         → 什么都不输出</span></span><br><span class="line"><span class="comment"># --format     → 设置监控信息输出的格式(-format &quot;%e %f %w %T&quot; → 分别代表事件、文件、目录、变化时间)</span></span><br><span class="line"><span class="comment"># --timefmt    → 设置时间格式</span></span><br><span class="line"><span class="comment"># -c          → 使用 csv 格式(标准列表信息输出格式)，使用逗号分隔</span></span><br><span class="line"><span class="comment"># -t          → 监控数据的超时时间(即只监控指定的时间，之后会停止监控)</span></span><br><span class="line"><span class="comment"># -e          → 指定监控的事件(create、delete、modify、move)，监控创建、修改、删除、移动、重命名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 事件</span></span><br><span class="line">access <span class="comment"># 文件或目录内容被读取时</span></span><br><span class="line">modify <span class="comment"># 文件或目录内容被写入时</span></span><br><span class="line">attrib <span class="comment"># 文件或目录属性被改变时</span></span><br><span class="line">close_write <span class="comment"># 文件或目录内容被关闭时(文件被改变了)</span></span><br><span class="line">close_nowrite <span class="comment"># 文件或目录内容关闭时(文件未改变)</span></span><br><span class="line">close <span class="comment"># 文件或目录内容被关闭</span></span><br><span class="line">open <span class="comment"># 文件或目录内容被打开</span></span><br><span class="line">moved_to <span class="comment"># 文件或目录从其他目录移入到监控目录</span></span><br><span class="line">moved_from <span class="comment"># 文件或目录从监控目录移出</span></span><br><span class="line">move <span class="comment"># 文件或目录移动</span></span><br><span class="line">create <span class="comment"># 创建文件或目录</span></span><br><span class="line">delete <span class="comment"># 删除文件或目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 监控目录数据信息变化：inotifywait -mrq --format &quot;%w%f&quot; -e &quot;modify,close_write,moved_to,moved_from,create,delete&quot; /backup</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>如何进行数据传输</strong></p>
<ol>
<li><p>利用脚本文件实现同步数据</p>
<figure class="highlight plain"><figcaption><span>sh</span></figcaption><table><tr><td class="code"><pre><span class="line"># 拓展：</span><br><span class="line"># \   → 可以将长的命令换行显示</span><br><span class="line"># while read 变量 → 实时读取输出信息的每一行</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量</span></span><br><span class="line"><span class="built_in">export</span> RSYNC_PASSWORD=linus</span><br><span class="line"></span><br><span class="line">inotifywait -mrq --format <span class="string">&quot;%w%f&quot;</span> -e <span class="string">&quot;modify,close_write,moved_to,moved_from,create,delete&quot;</span> /backup\</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> inotify_data</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	rsync -az --delete /backup/ linus@172.16.1.41::backup</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如何使脚本在后台运行(前台运行时断开连接即停止)</span></span><br><span class="line">nohup sh xxx.sh &amp;</span><br><span class="line"><span class="comment"># 对于二进制或者编译安装的软件，如何管理</span></span><br><span class="line"><span class="comment"># 1. kill pid # 停止服务进程</span></span><br><span class="line"><span class="comment"># 2. kill -9 pid # 强制停止服务进程</span></span><br><span class="line"><span class="comment"># 3. killall processname  (yum install -y psmisc)(问题：只能识别进程名空格分割的前面的部分)</span></span><br><span class="line"><span class="comment"># 4. pkill -f processname (可以识别进程名空格分割的后面的部分)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用软件工具实现同步数据(sersync)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://github.com/wsgzao/sersync</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.下载 sersync 软件</span></span><br><span class="line">wget https://github.com/wsgzao/sersync/archive/master.zip</span><br><span class="line"><span class="comment"># 2. 解压并移动</span></span><br><span class="line">unzip master.zip</span><br><span class="line"><span class="built_in">cd</span> sersync-master/</span><br><span class="line">tar xf sersync2.5.4_64bit_binary_stable_final.tar.gz</span><br><span class="line">mv GNU-Linux-x86/ /usr/<span class="built_in">local</span>/sersync/</span><br><span class="line"><span class="comment"># 3. 修改配置文件</span></span><br><span class="line">vim /usr/<span class="built_in">local</span>/sersync/confxml.xml</span><br><span class="line">&lt;localpath watch=<span class="string">&quot;/opt/tongbu&quot;</span>&gt;</span><br><span class="line">	&lt;remote ip=<span class="string">&quot;127.0.0.1&quot;</span> name=<span class="string">&quot;tongbu1&quot;</span>/&gt;</span><br><span class="line">	&lt;!--&lt;remote ip=<span class="string">&quot;192.168.8.39&quot;</span> name=<span class="string">&quot;tongbu&quot;</span>/&gt;--&gt;</span><br><span class="line">	&lt;!--&lt;remote ip=<span class="string">&quot;192.168.8.40&quot;</span> name=<span class="string">&quot;tongbu&quot;</span>/&gt;--&gt;</span><br><span class="line">&lt;/localpath&gt;</span><br><span class="line">&lt;rsync&gt;</span><br><span class="line">	&lt;commonParams params=<span class="string">&quot;-artuz&quot;</span>/&gt;</span><br><span class="line">	&lt;auth start=<span class="string">&quot;false&quot;</span> users=<span class="string">&quot;root&quot;</span> passwordfile=<span class="string">&quot;/etc/rsync.pas&quot;</span>/&gt;</span><br><span class="line">	&lt;userDefinedPort start=<span class="string">&quot;false&quot;</span> port=<span class="string">&quot;874&quot;</span>/&gt;&lt;!-- port=874 --&gt;</span><br><span class="line">	&lt;timeout start=<span class="string">&quot;false&quot;</span> time=<span class="string">&quot;100&quot;</span>/&gt;&lt;!-- timeout=100 --&gt;</span><br><span class="line">	&lt;ssh start=<span class="string">&quot;false&quot;</span>/&gt;</span><br><span class="line">&lt;/rsync&gt;</span><br><span class="line"><span class="comment"># 4. 启动服务程序</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/usr/local/sersync/:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line">sersync2 -dro /usr/<span class="built_in">local</span>/sersync/confxml.xml</span><br><span class="line"><span class="comment"># sersync2 常见参数说明</span></span><br><span class="line">/usr/<span class="built_in">local</span>/sersync/sersync2 -h</span><br><span class="line"><span class="comment"># 参数-d:启用守护进程模式</span></span><br><span class="line"><span class="comment"># 参数-r:在监控前，将监控目录与远程主机用rsync命令推送一遍</span></span><br><span class="line"><span class="comment"># 参数-o:指定配置文件，默认使用confxml.xml文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置文件</p>
<p><img src="https://zeuslb.github.io/img/sersync%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83%E5%9B%BE%E7%A4%BA.png" alt="sersync配置参考图示"></p>
</li>
<li><p>进程</p>
<ul>
<li>普通进程：执行完相应的任务即消失</li>
<li>守护进程：一直存在与进程中</li>
</ul>
</li>
</ul>
</li>
<li><p>lsyncd软件 (拓展)</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>nginx 部署与实践(四)</title>
    <url>/2020/12/22/nginx%20%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%9E%E8%B7%B5(%E5%9B%9B)/</url>
    <content><![CDATA[<h3 id="网站架构配置"><a href="#网站架构配置" class="headerlink" title="网站架构配置"></a>网站架构配置</h3><p><strong>nginx 服务配置</strong></p>
<p>目的是实现静态资源访问自己处理，动态资源访问交给 php 服务处理。</p>
<p>具体配置过程见下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">	root /html/www/;</span><br><span class="line">	fastcgi_index index.php; # php 服务默认处理动态资源</span><br><span class="line">	fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; # 告知 php 程序请求资源的具体地址</span><br><span class="line">	fastcgi_pass  127.0.0.1:9000; # 调取 fastcgi 接口，将 nginx 收到动态请求传输给本地 9000 端口，即传输给 php 程序</span><br><span class="line">	include fastcgi_params; # 引用加载识别fastcgi配置相关的变量文件</span><br><span class="line">	client_max_body_size 100m; # 设置上传大小限制</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$document_root</span>：root or <span class="built_in">alias</span> directive’s value <span class="keyword">for</span> the current request，即 /html/www/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$fastcgi_script_name</span>：request URI</span></span><br></pre></td></tr></table></figure>
<p>nginx 配置测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> php 测试文件</span></span><br><span class="line">vim /html/linus/test_php.php</span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><strong>php 配置</strong></p>
<p>目的是实现数据存储过程/实现存储大文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 编辑配置文件 /etc/php-fpm.d/www.conf</span></span><br><span class="line">vim /etc/php-fpm.d/www.conf</span><br><span class="line">user = apache # 调整为和 nginx 服务的 worker 进程用户相同/和后端存储服务目录属主信息相同</span><br><span class="line">group = apache</span><br><span class="line">listen = 127.0.0.1:9000; # 可以实现 php 与 nginx 服务分离(不同服务器)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 编辑配置文件 /etc/php.ini</span></span><br><span class="line">vim /etc/php.ini</span><br><span class="line">post_max_size = 8M # 设置 post 方式数据的最大大小</span><br><span class="line">upload_max_filesize = 2M # 设置上传数据的最大文件大小</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置时 post_max_size 大于 upload_max_filesize 为佳</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 重启服务</span></span><br><span class="line">systemctl restart php-fpm.service</span><br></pre></td></tr></table></figure>

<p><strong>mysql/mariadb 服务配置</strong></p>
<p>目的是为了实现和 php 服务进行连接，使数据可以正常地进行读写。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 给数据库的 root 用户设置密码</span></span><br><span class="line">mysqladmin -uroot password &quot;root&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 利用指定的用户和密码登录数据库</span></span><br><span class="line">mysql -uroot -proot</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. mysql关闭 DNS 反向解析</span></span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">============================</span><br><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br><span class="line">============================</span><br><span class="line">systemctl restart mariadb.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 测试配置是否成功(登录mysql后输入：)</span></span><br><span class="line">show variables like &quot;%skip%&quot;; </span><br><span class="line"><span class="meta">#</span><span class="bash"> skip_name_resolve 的值显示为 ON 即为配置成功</span></span><br></pre></td></tr></table></figure>

<p>关闭 DNS 反向解析的目的：DNS 反向解析打开时，多台 web 服务器与数据库服务器连接进行配置时均需要配置 ip 地址和对应的域名，不方便。关闭后，只需要配置可以访问数据库服务器的网段即可。</p>
<p>测试是否可以连接数据库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim test_mysql.php</span><br><span class="line">&lt;?php</span><br><span class="line"><span class="meta">	$</span><span class="bash">servername = <span class="string">&quot;localhost&quot;</span>;</span></span><br><span class="line"><span class="meta">	$</span><span class="bash">username = <span class="string">&quot;root&quot;</span>;</span></span><br><span class="line"><span class="meta">	$</span><span class="bash">password = <span class="string">&quot;root&quot;</span>;</span></span><br><span class="line"><span class="meta">	//$</span><span class="bash">link_id=mysql_connect(<span class="string">&#x27;主机名&#x27;</span>,<span class="string">&#x27;用户&#x27;</span>,<span class="string">&#x27;密码&#x27;</span>);</span></span><br><span class="line">	//mysql -u用户 -p密码 -h 主机</span><br><span class="line"><span class="meta">	$</span><span class="bash">conn = mysqli_connect(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>);</span></span><br><span class="line">	if ($conn) &#123;</span><br><span class="line">		echo &quot;mysql successful by root !\n&quot;;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		die(&quot;Connection failed: &quot; . mysqli_connect_error());</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="网站架构代码上线-手动"><a href="#网站架构代码上线-手动" class="headerlink" title="网站架构代码上线 (手动)"></a>网站架构代码上线 (手动)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 上传代码到网站根目录</span></span><br><span class="line">rz -y 或者 wget xxx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 创建网站数据库/操作数据库的用户</span></span><br><span class="line">show databases # 查询服务器上的所有数据库</span><br><span class="line">create database wp_db; # 创建数据库</span><br><span class="line">grant all on wq_db.* to linus@localhost identified by &quot;linus&quot;;# 创建用户 linus 且授权(all) 管理 wq_db 的所有表</span><br><span class="line">quit</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 网站页面初始化(开源) → 指定连接数据库</span></span><br></pre></td></tr></table></figure>

<h3 id="网站数据库服务分离"><a href="#网站数据库服务分离" class="headerlink" title="网站数据库服务分离"></a>网站数据库服务分离</h3><p><strong>目的</strong></p>
<p>实现 web 集群数据统一存储。</p>
<p><strong>分离过程</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 将数据库数据进行备份</span></span><br><span class="line">mysqldump -uroot -proot -A &gt; /tmp/web01_db.sql</span><br><span class="line">scp -rp /tmp/web01_db.sql 10.0.0.51:/tmp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 将数据迁移到独立数据库服务器上</span></span><br><span class="line">mysql -uroot -proot &lt; /tmp/web01_db.sql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. db 服务配置 → 使其 web 服务可以通过远程连接到数据库</span></span><br><span class="line">grant all on wq_db.* to linus@&quot;172.16.1.%&quot; identified by &quot;linus&quot;;</span><br><span class="line">select user,host from mysql.user;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. web 服务配置(修改数据库连接配置)</span></span><br><span class="line">grep -r &quot;xxx&quot; ./*</span><br><span class="line">vim ...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 测试</span></span><br><span class="line">mysql -uroot -proot -h172.16.1.51</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以通过实际的数据库更新数据来判断是否分离成功</span></span><br></pre></td></tr></table></figure>

<h3 id="网站调整数据存储过程"><a href="#网站调整数据存储过程" class="headerlink" title="网站调整数据存储过程"></a>网站调整数据存储过程</h3><p><strong>服务端 (nfs 服务器) 配置过程：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 创建相应存储目录</span></span><br><span class="line">mkdir -p /data/wq</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 创建目录管理用户，且更改属主属组</span></span><br><span class="line">useradd wq -u 1000 -M -s /sbin/nologin</span><br><span class="line">chown wq. /data/wq</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 更改配置文件 (已安装 nfs 服务)</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">==============================</span><br><span class="line">/data/wq 10.0.0.7(rw,sync,all_squash,anonuid=1000,anongid=1000)</span><br><span class="line">==============================</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 重启服务</span></span><br><span class="line">systemctl restart nfs.service</span><br></pre></td></tr></table></figure>

<p><strong>客户端 (web 服务器) 配置过程：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 将原有数据进行保存备份</span></span><br><span class="line">mv /html/linus/wp-content/uploads/* /tmp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 挂载使用 nfs (已安装 nfs 服务)</span></span><br><span class="line">mount -t nfs 10.0.0.31:/data/wq /html/linus/wp-content/uploads/</span><br><span class="line">df -h</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 实际操作进行配置验证</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>nginx 部署与实践(五)</title>
    <url>/2020/12/23/nginx%20%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%9E%E8%B7%B5(%E4%BA%94)/</url>
    <content><![CDATA[<h3 id="网站架构部署常见问题"><a href="#网站架构部署常见问题" class="headerlink" title="网站架构部署常见问题"></a>网站架构部署常见问题</h3><p><strong>网站无法部署成功</strong></p>
<p>确认 LNMP 架构部署完成且均成功启动。具体排查见下：</p>
<p>nginx 启动错误：<code>nginx -t</code> 排查是否是配置文件错误。不要混用 <code>nginx</code> 或者 <code>systemctl start nginx</code> ，启动错误的原因是可能已经启动了该服务，可以使用 <code>ps -ef | grep nginx</code> 进行排查，先 kill <code>master 进程</code>，再重新y启动。</p>
<p>php 启动错误：一般是配置文件错误。</p>
<p>mariadb 启动错误： 可能是出现了异常中断，可以 <code>rm -rf /var/lib/mysql/*</code> 然后重新启动即可。如果是 <code>/etc/my.conf</code> 配置文件问题，可以通过 <code>cp /usr/share.mysql/*.conf /etc/my.cnf</code> 进行恢复。</p>
<p><strong>网站初始化时无法连接数据库</strong></p>
<p>检查客户端配置是否正确。</p>
<p>检查服务端配置是否正确(是否创建相应网站数据库、是否授权用户管理对应的数据库)。</p>
<p><strong>网站使用时无法上传数据</strong></p>
<p>确认 nginx 限制 → 确认 php 限制 → 确认后端存储限制 →  确认网站自身设置。</p>
<h3 id="网站架构代码上线部署-LNMU-Python"><a href="#网站架构代码上线部署-LNMU-Python" class="headerlink" title="网站架构代码上线部署 (LNMU-Python)"></a>网站架构代码上线部署 (LNMU-Python)</h3><p>本项目网站代码使用地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 解决软件服务的相关依赖</span></span><br><span class="line">yum install -y openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel gcc gcc-c++ zlib zlib-devel python-devel sqlite-devel</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 升级系统的 python 版本</span></span><br><span class="line">wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz</span><br><span class="line">tar xf Python-3.6.5.tgz</span><br><span class="line">cd Python-3.6.5</span><br><span class="line">./configure --prefix=/usr/local/python3</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">ln -sf /usr/local/python3/bin/python3  /usr/bin/python</span><br><span class="line">ln -s /usr/local/python3/bin/pip3  /usr/bin/pip3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 解决 yum 问题</span></span><br><span class="line">vim /usr/bin/yum</span><br><span class="line">=========================================</span><br><span class="line">/usr/bin/python → /usr/bin/python2.7</span><br><span class="line">=========================================</span><br><span class="line">vim /usr/libexec/urlgrabber-ext-down</span><br><span class="line">=========================================</span><br><span class="line">/usr/bin/python → /usr/bin/python2.7</span><br><span class="line">=========================================</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 下载安装 uwsgi 和 django 服务</span></span><br><span class="line">pip3 install uwsgi</span><br><span class="line">pip3 install django==2.2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 上传代码文件到网站根目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 编写 nginx 服务配置文件</span></span><br><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	server_name python.oldboy.com;</span><br><span class="line">	client_max_body_size 100M;</span><br><span class="line">	location /static &#123;</span><br><span class="line">		alias /html/BBS/static/;</span><br><span class="line">	&#125;</span><br><span class="line">	location /media &#123;</span><br><span class="line">		alias /html/BBS/media;</span><br><span class="line">	&#125;</span><br><span class="line">	location / &#123;</span><br><span class="line">		index index.html;</span><br><span class="line">		include uwsgi_params;</span><br><span class="line">		uwsgi_pass 127.0.0.1:9999;</span><br><span class="line">		uwsgi_param UWSGI_SCRIPT BBS.wsgi;</span><br><span class="line">		uwsgi_param UWSGI_CHDIR /code/BBS;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. 编写 uwsgi 配置文件</span></span><br><span class="line">vim /html/BBS/BBS/uwsgi.ini</span><br><span class="line">[uwsgi]</span><br><span class="line">master = true</span><br><span class="line">uid = root</span><br><span class="line">gid = root</span><br><span class="line">chdir = /html/BBS/</span><br><span class="line">processes = 3</span><br><span class="line">socket = 127.0.0.1:9999 # 指定uwsgi服务程序监听地址和端口</span><br><span class="line">pidfile = /tmp/BBS.pid</span><br><span class="line">daemonize = /html/BBS/logs/BBS.log</span><br><span class="line">wsgi-file = BBS/wsgi.py # 加载wsgi.py文件 实现管理控制django程序服务</span><br><span class="line"><span class="meta">#</span><span class="bash"> 8. 数据库相关配置</span></span><br><span class="line">create database bbs charset utf8mb4;</span><br><span class="line">use bbs;</span><br><span class="line">source /code/BBS/bbs.sql;</span><br><span class="line"></span><br><span class="line">vim /code/BBS/BBS/settings.py</span><br><span class="line">=========================================</span><br><span class="line">DATABASES = &#123;</span><br><span class="line">	&#x27;default&#x27;: &#123;</span><br><span class="line">		&#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">		&#x27;NAME&#x27;: &#x27;bbs&#x27;,</span><br><span class="line">		&#x27;HOST&#x27;: &quot;127.0.0.1&quot;,</span><br><span class="line">		&#x27;USER&#x27;: &#x27;root&#x27;,</span><br><span class="line">		&#x27;PASSWORD&#x27;: &#x27;root&#x27;,</span><br><span class="line">		&#x27;PORT&#x27;: 3306,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">=========================================</span><br><span class="line"><span class="meta">#</span><span class="bash"> 9. 根据项目实际环境安装相应依赖/库</span></span><br><span class="line">pip3 install -i https://pypi.doubanio.com/simple/ -r /html/BBS/requirement.txt</span><br></pre></td></tr></table></figure>

<h3 id="网站架构负载均衡介绍"><a href="#网站架构负载均衡介绍" class="headerlink" title="网站架构负载均衡介绍"></a>网站架构负载均衡介绍</h3><p><strong>作用</strong></p>
<p>可以分担前端用户并发访问的压力；可以对前端用户的访问流量进行调度(理解：在更新网站代码时，网站可以不停止运营更新)。</p>
<p><strong>实现方式</strong></p>
<p>第一种方式为利用反向代理实现负载均衡。具有代表性的服务是 nginx 。</p>
<p>第二种方式为利用数据转发实现负载均衡。具有代表性的服务是 LVS 。</p>
<p>区别：利用反向代理实现负载均衡时，用户请求数据会经过反向代理服务处理后发送给后端，响应数据也会经过反向代理服务处理后发送给客户端。利用数据转发实现负载均衡时，请求数据会经过转发服务器直接发送给后端(不做处理)，响应数据可以直接由 web 服务器发送给客户端；反向代理支持4/7层的负载均衡，而数据转发仅支持4层的负载均衡。</p>
<p><strong>正向代理与反向代理</strong></p>
<p>反向代理：将外部用户请求可以代理进入到内部架构中，即 外(公网) → 内(私网)。</p>
<p>正向代理：将内部用户氢气去可以代理出去到外部网络中，即 内(私网) → 外(公网)。</p>
<h3 id="网站架构负载均衡部署"><a href="#网站架构负载均衡部署" class="headerlink" title="网站架构负载均衡部署"></a>网站架构负载均衡部署</h3><p><strong>负载均衡服务器部署</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 安装反向代理服务 nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 编写代理配置文件 vim /etc/nginx/conf.d/proxy.conf</span></span><br><span class="line">mv default.conf default.conf.bak</span><br><span class="line">vim /etc/nginx/conf.d/proxy.conf</span><br><span class="line">=======================================</span><br><span class="line">server &#123;</span><br><span class="line">	listen 80; # 端口</span><br><span class="line">	server_name localhost;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://web; # 反向代理调用指定集群</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">upstream web &#123; # 负载的集群名字，放在 server 的外面就相当于放到了 http 里面，定义集群节点信息</span><br><span class="line">    server 10.0.0.7:80;</span><br><span class="line">    server 10.0.0.8:80;</span><br><span class="line">    server 10.0.0.9:80;</span><br><span class="line">&#125;</span><br><span class="line">=======================================</span><br></pre></td></tr></table></figure>

<p><strong>web 集群节点配置</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 在对应的站点目录下创建相应的 index.html</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> web01</span></span><br><span class="line">echo &quot;www.linus.cc web01&quot; &gt; /html/linus/index.html</span><br><span class="line">echo &quot;www.phpsql.cc web01&quot; &gt; /html/phpsql/index.html</span><br><span class="line">sed -i &#x27;s/index.php/index.html/g&#x27; /etc/nginx/conf.d/&#123;linus,phpsql&#125;.conf</span><br><span class="line">systemctl restart nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> web02</span></span><br><span class="line">echo &quot;www.linus.cc web02&quot; &gt; /html/linus/index.html</span><br><span class="line">echo &quot;www.phpsql.cc web02&quot; &gt; /html/phpsql/index.html</span><br><span class="line"><span class="meta">#</span><span class="bash"> web03</span></span><br><span class="line">echo &quot;www.linus.cc web03&quot; &gt; /html/linus/index.html</span><br><span class="line">echo &quot;www.phpsql.cc web03&quot; &gt; /html/phpsql/index.html</span><br><span class="line">...(无差异同步)</span><br><span class="line">scp -pr 10.0.0.7:/html /</span><br><span class="line">scp -pr 10.0.0.7:/etc/nginx/conf.d/* /etc/nginx/conf.d</span><br><span class="line">rm -rf /etc/nginx/conf.d/default.conf</span><br><span class="line">ll /etc/nginx/conf.d/</span><br><span class="line">yum install -y nfs-utils</span><br><span class="line">rm -rf /html/linus/wp-content/uploads/*</span><br><span class="line">mount -t nfs 10.0.0.31:/data/wq /html/linus/wp-content/uploads/</span><br><span class="line">ll /html/linus/wp-content/uploads/</span><br></pre></td></tr></table></figure>

<p><strong>部署测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 负载均衡服务器使用代码进行测试</span></span><br><span class="line">curl -H host:www.linus.cc 10.0.0.7</span><br><span class="line">curl -H host:www.phpsql.cc 10.0.0.7</span><br><span class="line">curl -H host:www.linus.cc 10.0.0.8</span><br><span class="line">curl -H host:www.phpsql.cc 10.0.0.8</span><br><span class="line">curl -H host:www.linus.cc 10.0.0.9</span><br><span class="line">curl -H host:www.phpsql.cc 10.0.0.9</span><br><span class="line"><span class="meta">#</span><span class="bash"> 实际访问测试</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 将 windows 的 hosts 地址配置 10.0.0.5 www.linus.cc www.phpsql.cc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 浏览器打开网站测试</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p>创建 web 集群节点，需要保证三点信息一致，即部署的 web 服务程序一致(版本也一致)；部署 web 服务的配置一致；部署 web 服务的网站代码一致(灰度发布、金丝雀发布等特殊的发布需求时允许不一致的情况)。</p>
<h3 id="负载均衡调度算法与-upstream-常见参数"><a href="#负载均衡调度算法与-upstream-常见参数" class="headerlink" title="负载均衡调度算法与 upstream 常见参数"></a>负载均衡调度算法与 upstream 常见参数</h3><p><strong>轮询调度算法 rr</strong></p>
<p>将用户发出的请求平均分配到每一个 web 节点上(默认配置)。</p>
<p><strong>权重轮询算法 wrr</strong></p>
<p>按照一定比例分配用户请求流量信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream web &#123;</span><br><span class="line">	server 10.0.0.7:80 weight=4; # 5次有4次分配到该服务器(注意是按照比例，不是优先级)</span><br><span class="line">	server 10.0.0.8:80 weight=1; # 分配比为 1/5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>避免会话中断算法 ip_hash</strong></p>
<p><img src="https://zeuslb.github.io/img/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1ip_hash.jpg" alt="nginx负载均衡ip_hash"></p>
<p>每个请求按客户端IP的hash结果分配，当新的请求到达时，先将其客户端IP通过哈希算法哈希出一个值，在随后的客户端请求中，客户IP的哈希值只要相同，就会被分配至同一台服务器，该调度算法可以解决动态网页的session共享问题，但有时会导致请求分配不均，即无法保证1：1的负载均衡。</p>
<p>可以避免会话中断(用户需要反复登录)，但会出现负载分配不均的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream web &#123;</span><br><span class="line">	ip_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义最小的连接数 least_conn</strong></p>
<p>least_conn算法会根据后端节点的连接数来决定分配情况，哪个机器连接数少就分发。可以避免单个 web 节点压力过高。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream web &#123;</span><br><span class="line">	least_conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>upstream 配置</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream web &#123;</span><br><span class="line">	server 10.0.0.7:80 max_fails=2 fail_timeout=3s</span><br><span class="line">	server 10.0.0.7:80  </span><br><span class="line">	server 10.0.0.9:80 backup # 负载均衡热备参数</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> max_fails：配置最大失败次数 → 重试连接的最大次数，可以避免负载不均/可以对后端节点做健康节点，默认是1次</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> fail_timeout：在一段时间后对异常节点再次进行访问/测试，默认是10s</span></span><br></pre></td></tr></table></figure>

<p>对于 max_fails 可以避免负载不均的理解：因为失败的节点只是因为某一时间段会出问题，如果不配置max_fails或者该值过低的时候，也许下一次尝试就可以访问了，但是因为配置的问题从而将请求转到了其他节点，这时就会造成其他可用节点的负载变高。在真实企业环境需要根据实际情况具体分析，一般来说，max_fails和fail_timeout的值和网站规模成反比。</p>
<p><strong>热备参数说明</strong></p>
<p>只有所有节点出现故障时，才会使用热备节点。企业用于在自动代码上线时作为临时服务器使用。注意上线操作一般需要在晚上的低流量期进行，防止热备服务器因流量过大宕机。</p>
<h3 id="负载均衡反向代理配置参数"><a href="#负载均衡反向代理配置参数" class="headerlink" title="负载均衡反向代理配置参数"></a>负载均衡反向代理配置参数</h3><p><strong>常见参数</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxy_set_header # 可以修改负载均衡向后端节点访问过程中的HTTP请求报文信息(请求头信息)</span><br><span class="line">proxy_next_upstream # 当网站页面(代码)出现错误时，可以将访问请求切换到其他节点进行访问</span><br></pre></td></tr></table></figure>

<p><strong>如何实现通过负载均衡访问不同的后端网站页面</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">	proxy_set_header Host $host; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>web 节点日志文件中如何记录客户端真实 ip 地址</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">	proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>某节点网站代码错误时如何配置使其访问其他节点</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">	 proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504 http_403 http_404 http_429;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> PS：并没有将坏的节点忽略不再访问，还会尝试访问，可以通过日志文件查看到</span></span><br></pre></td></tr></table></figure>

<h3 id="负载均衡企业应用"><a href="#负载均衡企业应用" class="headerlink" title="负载均衡企业应用"></a>负载均衡企业应用</h3><p><strong>实现动静分离访问过程</strong></p>
<p>根据请求 uri 的不同来访问不同的集群。</p>
<p>web 集群环境准备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 10.0.0.7</span></span><br><span class="line">mkdir /html/linus/static/</span><br><span class="line">echo &quot;web01 www.linus.cc-static&quot; &gt; /html/linus/static/index.html</span><br><span class="line"><span class="meta">#</span><span class="bash"> 10.0.0.8</span></span><br><span class="line">mkdir /html/linus/upload/</span><br><span class="line">echo &quot;web01 www.linus.cc-upload&quot; &gt; /html/linus/upload/index.html</span><br><span class="line"><span class="meta">#</span><span class="bash"> 10.0.0.9</span></span><br><span class="line">mkdir /html/linus/default/</span><br><span class="line">echo &quot;web01 www.linus.cc-default&quot; &gt; /html/linus/default/index.html</span><br></pre></td></tr></table></figure>

<p>负载均衡配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream static &#123;</span><br><span class="line">	server 10.0.0.7:80</span><br><span class="line">&#125;</span><br><span class="line">upstream upload &#123;</span><br><span class="line">	server 10.0.0.8:80</span><br><span class="line">&#125;</span><br><span class="line">upstream default &#123;</span><br><span class="line">	server 10.0.0.9:80</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">	listen 80; </span><br><span class="line">	server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://default;</span><br><span class="line">        proxy_set_header Host $host; </span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504 http_403 http_404 http_429;</span><br><span class="line">    &#125;</span><br><span class="line">    location /static/ &#123;</span><br><span class="line">        proxy_pass http://static;</span><br><span class="line">        proxy_set_header Host $host; </span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504 http_403 http_404 http_429;</span><br><span class="line">    &#125;</span><br><span class="line">    location /upload/ &#123;</span><br><span class="line">        proxy_pass http://upload;</span><br><span class="line">        proxy_set_header Host $host; </span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504 http_403 http_404 http_429;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现不同 UA 访问页面效果</strong></p>
<p>web 集群环境准备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 10.0.0.7</span></span><br><span class="line">echo &quot;mobile website&quot; &gt; /html/linus/index.html</span><br><span class="line"><span class="meta">#</span><span class="bash"> 10.0.0.8</span></span><br><span class="line">echo &quot;pc website&quot; &gt; /html/linus/index.html</span><br></pre></td></tr></table></figure>

<p>负载均衡配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream mobile &#123;</span><br><span class="line">	server 10.0.0.7:80</span><br><span class="line">&#125;</span><br><span class="line">upstream pc &#123;</span><br><span class="line">	server 10.0.0.8:80</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">	listen 80; </span><br><span class="line">	server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">    	if ($http_user_agent ~* &quot;iphone|android&quot;) &#123;</span><br><span class="line">    		proxy_pass http://mobile;</span><br><span class="line">    	&#125;</span><br><span class="line">    	proxy_pass http://pc;</span><br><span class="line">        proxy_set_header Host $host; </span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>高可用 keepalived 部署</title>
    <url>/2020/12/25/%E9%AB%98%E5%8F%AF%E7%94%A8%20keepalived%20%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="负载均衡反向代理服务基础优化"><a href="#负载均衡反向代理服务基础优化" class="headerlink" title="负载均衡反向代理服务基础优化"></a>负载均衡反向代理服务基础优化</h3><p>建议将以下的优化配置放到一个文件中，然后在 <code>server &#123;&#125;</code> 中使用 <code>include xxx/xxx/xxx_conf</code> 引用即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxy_connect_timeout 20S; # 代理与web节点通讯空闲超时时间设置，默认60s，目的是为了尽快释放连接资源</span><br><span class="line">proxy_send_timeout 60s; # 代理节点发送用户请求信息超时时间</span><br><span class="line">proxy_read_timeout 60s; # web节点响应超时时间</span><br><span class="line"></span><br><span class="line">proxy_buffering on/off; # 是否开启缓冲功能，默认是打开的</span><br><span class="line">proxy_buffer_size 8k; # 缓冲头部信息大小，存储 HTTP 请求的请求头信息</span><br><span class="line">proxy_buffers 8 4k; # 缓冲数据的总大小 → 8 x 4k = 32kb，存储 HTTP 请求的请求主体信息</span><br></pre></td></tr></table></figure>

<p> <strong><code>$proxy_add_x_forwarded_for</code> 与 <code>$remote_addr</code></strong></p>
<p><code> $remote_addr</code>：记录上一级客户端或代理服务器IP地址。</p>
<p><code>$proxy_add_x_forwarded_for</code>：记录客户端真实 IP 地址，以及经过多级代理后每个代理节点 IP 地址。</p>
<h3 id="网站缓存服务配置"><a href="#网站缓存服务配置" class="headerlink" title="网站缓存服务配置"></a>网站缓存服务配置</h3><p>nginx 有缓存功能，可以缓存<code>静态对象</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 创建缓存存储环境</span></span><br><span class="line">mkdir /tmp/ngx_cache</span><br><span class="line">mount -t tmpfs -o size=100M tmpfs /tmp/ngx_cache # 将内存挂载到指定目录上</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 编写配置文件</span></span><br><span class="line">  proxy_cache_path /tmp/ngx_cache levels=2:1 keys_zone=cache_one:100m inactive=1d max_size=5g; # 设置缓存区域信息</span><br><span class="line">   upstream web01 &#123;</span><br><span class="line">        server  10.0.0.7:80;</span><br><span class="line">      &#125;</span><br><span class="line">   server &#123;</span><br><span class="line">      listen   80;</span><br><span class="line">      server_name  localhost;</span><br><span class="line">      include /etc/nginx/proxy_conf;</span><br><span class="line">      location / &#123;</span><br><span class="line">	     add_header X-Cache-Status $upstream_cache_status; # 可以再响应头部信息中查看缓存命中情况</span><br><span class="line">         proxy_set_header Host $host;</span><br><span class="line">         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">         proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504 http_403 http_404 http_429;</span><br><span class="line">         proxy_pass http://web01;</span><br><span class="line">         proxy_cache cache_one; # 加载缓存区域</span><br><span class="line">		 proxy_cache_valid 200 304 12h; # 根据后端返回状态码信息进行缓存</span><br><span class="line">         proxy_cache_valid 301 302 1m;</span><br><span class="line">         proxy_cache_valid any 1m;</span><br><span class="line">         proxy_cache_key $host$uri$is_args$args; # 设置缓存文件存储格式信息</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="高可用服务介绍"><a href="#高可用服务介绍" class="headerlink" title="高可用服务介绍"></a>高可用服务介绍</h3><p>keepalived 实现高可用功能主要是借助了 VRRP 协议原理，实现了服务器设备之间的主备关系。当主服务期出现故障时，可以自动使用备服务器顶替主服务器。</p>
<h3 id="高可用服务原理"><a href="#高可用服务原理" class="headerlink" title="高可用服务原理"></a>高可用服务原理</h3><p>VRRP，即虚拟路由冗余协议。</p>
<ol>
<li>主备服务器之间需要使用 VRRP 协议交流<ol>
<li>主告诉备我还活着</li>
<li>主备之间竞选机制</li>
</ol>
</li>
<li>对主服务器进行虚拟ip地址标识<ol>
<li>vip地址在主备服务器之间的切换过程称为ip地址漂移过程</li>
</ol>
</li>
<li>当主服务器恢复后，会进行资源抢占</li>
</ol>
<h3 id="高可用服务部署"><a href="#高可用服务部署" class="headerlink" title="高可用服务部署"></a>高可用服务部署</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 安装 keepalived 服务</span></span><br><span class="line">yum install -y keepalived</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 编写配置文件</span></span><br><span class="line">vim /etc/keepalived/keepalived.conf</span><br><span class="line">[root@lb01 ~]# cat /etc/keepalived/keepalived.conf </span><br><span class="line">! Configuration File for keepalived</span><br><span class="line">global_defs &#123;</span><br><span class="line">	router_id lb01 # 高可用服务主机标识，区分主机</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123; # 建立一个高可用集群环境</span><br><span class="line">	state MASTER # 简单描述此服务器身份(MASTER/BACKUP)，此配置无法决定真正的主服务器或者备服务器</span><br><span class="line">	interface eth0 # 设置 vip 地址出现在哪个网卡上(一般为外网网卡)</span><br><span class="line">	virtual_router_id 51 # 高可用服务主机标识，区分集群，相同集群中的主机该值均相同</span><br><span class="line">	priority 150 # 优先级最大的为主(一般100-200之间)</span><br><span class="line">	advert_int 1 # 发送/接收vrrp组播报的时间间隔(秒)，注意主备需要相同，即主备收发需要同步</span><br><span class="line">	authentication &#123; # 实现主备通讯认证过程</span><br><span class="line">		auth_type PASS</span><br><span class="line">		auth_pass 1111</span><br><span class="line">	&#125;</span><br><span class="line">	virtual_ipaddress &#123; # 设置虚拟 ip 地址(公网地址，网站域名与该ip地址匹配)</span><br><span class="line">		10.0.0.3</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">[root@lb02 ~]# cat /etc/keepalived/keepalived.conf</span><br><span class="line">   ! Configuration File for keepalived</span><br><span class="line">   </span><br><span class="line">   global_defs &#123;</span><br><span class="line">      router_id lb02</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   vrrp_instance VI_1 &#123;</span><br><span class="line">       state BACKUP</span><br><span class="line">       interface eth0</span><br><span class="line">       virtual_router_id 51</span><br><span class="line">       priority 100</span><br><span class="line">       advert_int 1</span><br><span class="line">       authentication &#123;</span><br><span class="line">           auth_type PASS</span><br><span class="line">           auth_pass 1111</span><br><span class="line">       &#125;</span><br><span class="line">       virtual_ipaddress &#123;</span><br><span class="line">           10.0.0.3</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 启动服务</span></span><br><span class="line">systemctl start keepalived.service</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>中小型架构配置实践文档</title>
    <url>/2020/12/27/%E4%B8%AD%E5%B0%8F%E5%9E%8B%E6%9E%B6%E6%9E%84%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h3 id="一-架构与需求"><a href="#一-架构与需求" class="headerlink" title="一. 架构与需求"></a>一. 架构与需求</h3><p><strong>架构图</strong></p>
<p><img src="https://zeuslb.github.io/img/%E4%B8%AD%E5%B0%8F%E5%9E%8B%E4%BC%81%E4%B8%9A%E5%AE%9E%E8%B7%B5%E6%9E%B6%E6%9E%84%E8%A7%84%E5%88%92%E5%9B%BE.png" alt="中小型企业实践架构规划图"></p>
<p><strong>需求</strong></p>
<ol>
<li>基础功能：搭建 wordpress 网站。</li>
<li>架构：LNMP 架构</li>
</ol>
<h3 id="二-数据库服务器部署"><a href="#二-数据库服务器部署" class="headerlink" title="二. 数据库服务器部署"></a>二. 数据库服务器部署</h3><p><strong>mariadb 服务部署</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 安装 mariadb 相关软件并启动服务</span></span><br><span class="line">[root@db01 ~]# yum install mariadb-server mariadb -y</span><br><span class="line">[root@db01 ~]# systemctl start mariadb.service </span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 为 root 用户设置密码，并进行测试</span></span><br><span class="line">[root@db01 ~]# mysqladmin -uroot password &quot;root&quot;</span><br><span class="line">[root@db01 ~]# mysql -uroot -proot</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 关闭 dns 解析功能</span></span><br><span class="line">[root@db01 ~]# vim /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve # 新增该指令</span><br><span class="line">[root@db01 ~]# systemctl restart mariadb.service</span><br><span class="line">[root@db01 ~]# mysql -uroot -proot</span><br><span class="line">MariaDB [(none)]&gt; show variables like &quot;%skip%&quot;; # skip_name_resolve = ON 即为配置成功</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 创建网站所用的db，并创建管理该站点数据库的用户</span></span><br><span class="line">MariaDB [(none)]&gt; create database wq_db;</span><br><span class="line">MariaDB [(none)]&gt; grant all on wq_db.* to wq_root@&quot;10.0.0.%&quot; identified by &quot;wq_root&quot;;</span><br><span class="line">MariaDB [(none)]&gt; select user,host from mysql.user;</span><br></pre></td></tr></table></figure>

<h3 id="三-web-服务器部署"><a href="#三-web-服务器部署" class="headerlink" title="三. web 服务器部署"></a>三. web 服务器部署</h3><p><strong>nginx 服务部署</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> web01、web02、web03 操作均相同</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 更改官方源</span></span><br><span class="line">[root@web01 ~]# vim /etc/yum.repos.d/nginx.repo</span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 下载 nginx 软件</span></span><br><span class="line">[root@web01 ~]# yum install -y nginx</span><br><span class="line">[root@web01 ~]# nginx -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 创建站点目录</span></span><br><span class="line">[root@web01 ~]# mkdir /html/wq -p</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 创建站点管理用户，修改属主属组</span></span><br><span class="line">[root@web01 ~]# cat /etc/passwd | grep 1000</span><br><span class="line">[root@web01 ~]# useradd www -u 1000 -M -s /sbin/nologin</span><br><span class="line">[root@web01 ~]# chown www. /html/wq/ -R</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 修改配置文件</span></span><br><span class="line">[root@web01 ~]# mv /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.conf.bak</span><br><span class="line">[root@web01 ~]# vim /etc/nginx/conf.d/wq.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.wq.com;</span><br><span class="line">    error_log  /var/log/nginx/wq_error.log warn;</span><br><span class="line">    access_log  /var/log/nginx/wq_access.log main;</span><br><span class="line">    location / &#123;</span><br><span class="line">		root /html/wq/;</span><br><span class="line">		index index.php;</span><br><span class="line">    &#125;</span><br><span class="line">    location /basic_status &#123;</span><br><span class="line">		stub_status;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">		root /html/wq/;</span><br><span class="line">		fastcgi_index index.php;</span><br><span class="line">		fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">		fastcgi_pass  127.0.0.1:9000;</span><br><span class="line">		include fastcgi_params;</span><br><span class="line">		client_max_body_size 100m;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@web01 ~]# vim /etc/nginx/nginx.conf </span><br><span class="line">user www;</span><br><span class="line">worker_processes 1;</span><br><span class="line"><span class="meta">#</span><span class="bash">error_log /var/<span class="built_in">log</span>/nginx/error.log warn;</span></span><br><span class="line">pid /var/run/nginx.pid;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include /etc/nginx/mime.types;</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line">    log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">    #access_log /var/log/nginx/access.log  main;</span><br><span class="line">    sendfile on;</span><br><span class="line">    #tcp_nopush on;</span><br><span class="line">    keepalive_timeout 65;</span><br><span class="line">    #gzip on;</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 检查配置文件并重启服务</span></span><br><span class="line">[root@web01 ~]# nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br><span class="line">[root@web01 ~]# systemctl restart nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. 上传网站代码</span></span><br><span class="line">[root@web01 ~]# cd /html/wq/</span><br><span class="line">[root@web01 wq]# rz -E</span><br><span class="line">rz waiting to receive.</span><br><span class="line">[root@web01 wq]# ll /html/wq/</span><br><span class="line">total 15712</span><br><span class="line">-rw-r--r-- 1 root root 16087243 Dec 22 15:07 wordpress-5.6-zh_CN.tar.gz</span><br><span class="line">[root@web01 wq]# tar xf wordpress-5.6-zh_CN.tar.gz</span><br><span class="line">[root@web01 wq]# ll</span><br><span class="line">total 15716</span><br><span class="line">drwxr-xr-x 5 1006 1006     4096 Dec 20 19:00 wordpress</span><br><span class="line">-rw-r--r-- 1 root root 16087243 Dec 22 15:07 wordpress-5.6-zh_CN.tar.gz</span><br><span class="line">[root@web01 wq]# mv ./wordpress/* ./</span><br><span class="line"><span class="meta">#</span><span class="bash"> 8. 更改属主属组</span></span><br><span class="line">[root@web01 wq]# chown www. /html -R</span><br><span class="line"><span class="meta">#</span><span class="bash"> 9. 配置 windows 主机模拟解析环境</span></span><br><span class="line">C:\Windows\system32\drivers\etc\hosts</span><br></pre></td></tr></table></figure>

<p><strong>php 服务部署</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 优化下载源</span></span><br><span class="line">[root@web01 ~]# rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br><span class="line">[root@web01 ~]# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 下载 php 软件服务与依赖</span></span><br><span class="line">[root@web01 ~]# yum remove php-mysql php php-fpm php-common</span><br><span class="line">[root@web01 ~]# yum install -y php71w php71w-cli php71w-common php71w-devel php71w-embedded  php71w-gd php71w-mcrypt php71w-mbstring php71w-pdo php71w-xml php71w-fpm php71w-mysqlnd php71w-opcache  php71w-pecl-memcached php71w-pecl-redis php71w-pecl-mongodb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 编辑配置文件 /etc/php-fpm.d/www.conf</span></span><br><span class="line">[root@web01 ~]# vim /etc/php-fpm.d/www.conf</span><br><span class="line">user = www</span><br><span class="line">group = www</span><br><span class="line">listen = 127.0.0.1:9000; # 默认</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 编辑配置文件 /etc/php.ini</span></span><br><span class="line">[root@web01 ~]# vim /etc/php.ini</span><br><span class="line">post_max_size = 100M</span><br><span class="line">upload_max_filesize = 100M</span><br></pre></td></tr></table></figure>

<h3 id="四-存储服务器部署"><a href="#四-存储服务器部署" class="headerlink" title="四. 存储服务器部署"></a>四. 存储服务器部署</h3><p><strong>nfs 服务部署 - 10.0.0.31</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 安装 nfs 软件</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 创建相应的存储目录</span></span><br><span class="line">[root@nfs01 ~]# mkdir /data/web/wq_site -p</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 创建目录管理用户，并更改目录的属主和属组</span></span><br><span class="line">[root@nfs01 ~]# cat /etc/passwd | grep 1000</span><br><span class="line">[root@nfs01 ~]# useradd www -u 1000 -M -s /sbin/nologin</span><br><span class="line">[root@nfs01 ~]# chown www. /data/web/ -R</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 更改配置文件</span></span><br><span class="line">[root@nfs01 ~]# vim /etc/exports</span><br><span class="line">/data/web/wq_site 10.0.0.0/24(rw,sync,anonuid=1000,anongid=1000)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 重启服务</span></span><br><span class="line">[root@nfs01 ~]# systemctl restart nfs.service</span><br></pre></td></tr></table></figure>

<p><strong>nfs 服务部署 - web 服务器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 安装 nfs 软件</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 备份数据</span></span><br><span class="line">[root@web01 ~]# mv /html/wq/wp-content/uploads/* /tmp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 挂载</span></span><br><span class="line">[root@web01 ~]# mount -t nfs 10.0.0.31:/data/web/wq_site /html/wq/wp-content/uploads/</span><br><span class="line">[root@web01 ~]# df -h</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 还原数据</span></span><br><span class="line">[root@web01 ~]# mv /tmp/2020/ /html/wq/wp-content/uploads</span><br></pre></td></tr></table></figure>

<p><strong>网站功能测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. nfs 配置功能测试</span></span><br><span class="line">[root@nfs01 ~]# ll /data/web/wq_site/</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 3 www www 16 Dec 27 10:31 2020</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 访问：10.0.0.7/wp-admin 测试 web01 功能(发布文章，包含图片)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 访问：10.0.0.8/wp-admin 测试 web02 功能(发布文章，包含图片)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 访问：10.0.0.9/wp-admin 测试 web03 功能(发布文章，包含图片)</span></span><br></pre></td></tr></table></figure>

<h3 id="五-负载均衡服务器部署"><a href="#五-负载均衡服务器部署" class="headerlink" title="五. 负载均衡服务器部署"></a>五. 负载均衡服务器部署</h3><p><strong>负载均衡功能配置</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> lb01、lb02 操作均相同</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 更改官方源</span></span><br><span class="line">[root@lb01 ~]# vim /etc/yum.repos.d/nginx.repo</span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 下载 nginx 软件</span></span><br><span class="line">[root@lb01 ~]# yum install -y nginx</span><br><span class="line">[root@lb01 ~]# nginx -v</span><br><span class="line">[root@lb01 ~]# mv /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.conf.bak</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 编写配置文件</span></span><br><span class="line">[root@lb01 ~]# vim /etc/nginx/conf.d/proxy.conf</span><br><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	server_name localhost;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://web;</span><br><span class="line">		proxy_set_header Host $host; </span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504 http_403 http_404 http_429;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">upstream web &#123; </span><br><span class="line">    server 10.0.0.7:80 max_fails=2 fail_timeout=3s;</span><br><span class="line">    server 10.0.0.8:80 max_fails=2 fail_timeout=3s;</span><br><span class="line">    server 10.0.0.9:80 max_fails=2 fail_timeout=3s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 重启服务</span></span><br><span class="line">[root@lb01 ~]# nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br><span class="line">[root@lb01 ~]# systemctl restart nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 测试负载均衡是否成功</span></span><br><span class="line">[root@web01 ~]# echo &quot;web01 index.html&quot; &gt; /html/wq/index.html</span><br><span class="line">[root@web02 ~]# echo &quot;web02 index.html&quot; &gt; /html/wq/index.html</span><br><span class="line">[root@web03 ~]# echo &quot;web03 index.html&quot; &gt; /html/wq/index.html</span><br><span class="line"><span class="meta">#</span><span class="bash"> 浏览器输入 10.0.0.5/index.html 和 10.0.0.6/index.html</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停掉web01-03任一一台服务器的 nginx 服务，继续访问测试</span></span><br></pre></td></tr></table></figure>

<p><strong>nginx 日志切割时间结尾配置</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@web01 ~]# vim /etc/logrotate.d/nginx</span><br><span class="line">dateext # 新增</span><br><span class="line">[root@web01 ~]# systemctl restart nginx</span><br></pre></td></tr></table></figure>

<p><strong>nginx 服务优化配置</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> lb01、lb02 操作均相同</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 编辑配置文件 → 在 location / &#123;&#125; 中新增</span></span><br><span class="line">[root@lb02 ~]# vim /etc/nginx/conf.d/proxy.conf</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_connect_timeout 20s;</span><br><span class="line">    proxy_send_timeout 60s;</span><br><span class="line">    proxy_read_timeout 60s;</span><br><span class="line">    proxy_buffering on;</span><br><span class="line">    proxy_buffer_size 8k;</span><br><span class="line">    proxy_buffers 8 4k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 重启服务</span></span><br><span class="line">[root@lb01 ~]# nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br><span class="line">[root@lb01 ~]# systemctl restart nginx</span><br></pre></td></tr></table></figure>

<p><strong>nginx cache 缓存功能配置</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> lb01、lb02 操作均相同</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 创建缓存目录并挂载</span></span><br><span class="line">[root@lb01 ~]# mkdir /tmp/nginx_cache</span><br><span class="line">[root@lb01 ~]# mount -t tmpfs -o size=100M tmpfs /tmp/nginx_cache</span><br><span class="line">[root@lb01 ~]# df -h</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 编辑配置文件</span></span><br><span class="line">[root@lb01 ~]# vim /etc/nginx/conf.d/proxy.conf</span><br><span class="line">proxy_cache_path /tmp/nginx_cache levels=2:1 keys_zone=cache_one:100m inactive=1d max_size=5g;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://web;</span><br><span class="line">    	proxy_set_header Host $host;</span><br><span class="line">    	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    	proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504 http_403 http_404 http_429;</span><br><span class="line">    	</span><br><span class="line">    	proxy_connect_timeout 20s;</span><br><span class="line">    	proxy_send_timeout 60s;</span><br><span class="line">    	proxy_read_timeout 60s;</span><br><span class="line">    	proxy_buffering on;</span><br><span class="line">    	proxy_buffer_size 8k;</span><br><span class="line">    	proxy_buffers 8 4k;</span><br><span class="line">    	</span><br><span class="line">    	proxy_cache cache_one;</span><br><span class="line">        proxy_cache_valid 200 304 12h;</span><br><span class="line">        proxy_cache_valid 301 302 1m;</span><br><span class="line">        proxy_cache_valid any 1m;</span><br><span class="line">        proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">        add_header X-Cache-Status $upstream_cache_status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">upstream web &#123;</span><br><span class="line">    server 10.0.0.7:80 max_fails=2 fail_timeout=3s;</span><br><span class="line">    server 10.0.0.8:80 max_fails=2 fail_timeout=3s;</span><br><span class="line">    server 10.0.0.9:80 max_fails=2 fail_timeout=3s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. cache 缓存功能测试：多次刷新页面，F12 查看响应头 → X-Cache-Status: HIT</span></span><br><span class="line">[root@lb01 ~]# rm -rf /tmp/nginx_cache/*</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除缓存后刷新页面</span></span><br><span class="line">[root@lb02 ~]# rm -rf /tmp/nginx_cache/*</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除缓存后刷新页面</span></span><br></pre></td></tr></table></figure>

<p><strong>高可用功能配置</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> lb01、lb02 操作大致相同</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 安装 keepalived 软件</span></span><br><span class="line">[root@lb01 ~]# yum install -y keepalived</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 编辑配置文件</span></span><br><span class="line">[root@lb01 ~]# vim /etc/keepalived/keepalived.conf</span><br><span class="line">! Configuration File for keepalived</span><br><span class="line">global_defs &#123;</span><br><span class="line">	router_id lb01</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">	state MASTER</span><br><span class="line">	interface eth0</span><br><span class="line">	virtual_router_id 51</span><br><span class="line">	priority 150</span><br><span class="line">	advert_int 1</span><br><span class="line">	authentication &#123;</span><br><span class="line">		auth_type PASS</span><br><span class="line">		auth_pass 1111</span><br><span class="line">	&#125;</span><br><span class="line">	virtual_ipaddress &#123;</span><br><span class="line">		10.0.0.3</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@lb02 ~]# vim /etc/keepalived/keepalived.conf</span><br><span class="line">! Configuration File for keepalived</span><br><span class="line">global_defs &#123;</span><br><span class="line">  router_id lb02</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">   state BACKUP</span><br><span class="line">   interface eth0</span><br><span class="line">   virtual_router_id 51</span><br><span class="line">   priority 100</span><br><span class="line">   advert_int 1</span><br><span class="line">   authentication &#123;</span><br><span class="line">	   auth_type PASS</span><br><span class="line">	   auth_pass 1111</span><br><span class="line">   &#125;</span><br><span class="line">   virtual_ipaddress &#123;</span><br><span class="line">	   10.0.0.3</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 启动服务</span></span><br><span class="line">systemctl start keepalived.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 配置域名映射 C:\Windows\system32\drivers\etc\hosts</span></span><br><span class="line">10.0.0.3 www.wq.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 测试服务是否正常</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 wireshark 抓包 (vrrp协议)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭一台负载服务器的keepalived服务，访问 www.wq.com 确认是否可以正常切换</span></span><br></pre></td></tr></table></figure>

<h3 id="六-备份服务器部署"><a href="#六-备份服务器部署" class="headerlink" title="六. 备份服务器部署"></a>六. 备份服务器部署</h3><p><strong>备份服务器 rsync 部署</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 安装软件</span></span><br><span class="line">[root@backup ~]# yum install -y rsync</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 创建管理用户、目录、更改属主、创建密码文件、改权限为600</span></span><br><span class="line">[root@backup ~]# useradd rsync -M -s /sbin/nologin</span><br><span class="line">[root@backup ~]# mkdir /backup/&#123;nfs,web,lb&#125; -p</span><br><span class="line">[root@backup ~]# chown rsync. /backup -R</span><br><span class="line">[root@backup ~]# echo -e &#x27;nfs:nfs\nweb:web\nlb:lb&#x27; &gt; /etc/rsync.password</span><br><span class="line">[root@backup ~]# chmod 600 /etc/rsync.password</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 编写配置文件</span></span><br><span class="line">[root@backup ~]# vim /etc/rsyncd.conf</span><br><span class="line">uid = rsync</span><br><span class="line">gid = rsync</span><br><span class="line">port = 873</span><br><span class="line">fake super = yes</span><br><span class="line">use chroot = no</span><br><span class="line">max connections = 200</span><br><span class="line">timeout = 300</span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line">lock file = /var/run/rsync.lock</span><br><span class="line">log file = /var/log/rsyncd.log</span><br><span class="line">ignore errors</span><br><span class="line">read only = false</span><br><span class="line">list = false</span><br><span class="line">hosts allow = 10.0.0.0/24</span><br><span class="line">hosts deny = 0.0.0.0/32</span><br><span class="line">secrets file = /etc/rsync.password</span><br><span class="line">[web_bak]</span><br><span class="line">auth users = web</span><br><span class="line">comment = &quot;web backup&quot;</span><br><span class="line">path = /backup/web/</span><br><span class="line">[nfs_bak]</span><br><span class="line">auth users = nfs</span><br><span class="line">comment = &quot;nfs backup&quot;</span><br><span class="line">path = /backup/nfs/</span><br><span class="line">[lb_bak]</span><br><span class="line">auth users = lb</span><br><span class="line">comment = &quot;lb backup&quot;</span><br><span class="line">path = /backup/lb/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 启动服务</span></span><br><span class="line">[root@backup ~]# systemctl start rsyncd</span><br></pre></td></tr></table></figure>

<p><strong>存储服务器 sersync 部署</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 创建密码文件</span></span><br><span class="line">[root@nfs01 ~]# echo nfs &gt; /etc/rsync.pas</span><br><span class="line">[root@nfs01 ~]# chmod 600 /etc/rsync.pas</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 下载 sersync 并安装</span></span><br><span class="line">[root@nfs01 ~]# wget https://github.com/wsgzao/sersync/archive/master.zip</span><br><span class="line">[root@nfs01 ~]# unzip master.zip</span><br><span class="line">[root@nfs01 ~]# cd sersync-master/</span><br><span class="line">[root@nfs01 sersync-master]# tar xf sersync2.5.4_64bit_binary_stable_final.tar.gz</span><br><span class="line">[root@nfs01 sersync-master]# mv GNU-Linux-x86/ /usr/local/sersync/</span><br><span class="line">[root@nfs01 sersync-master]# vim /etc/profile</span><br><span class="line">export PATH=&quot;/usr/local/sersync/:$PATH&quot;</span><br><span class="line">[root@nfs01 sersync-master]# . /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 编辑配置文件</span></span><br><span class="line">[root@nfs01 sersync-master]# vim /usr/local/sersync/confxml.xml</span><br><span class="line">&lt;localpath watch=&quot;/data/&quot;&gt;</span><br><span class="line">	&lt;remote ip=&quot;10.0.0.41&quot; name=&quot;nfs_bak&quot;/&gt;</span><br><span class="line">&lt;/localpath&gt;</span><br><span class="line">&lt;rsync&gt;</span><br><span class="line">	&lt;commonParams params=&quot;-az&quot;/&gt;</span><br><span class="line">	&lt;auth start=&quot;true&quot; users=&quot;nfs&quot; passwordfile=&quot;/etc/rsync.pas&quot;/&gt;</span><br><span class="line">	&lt;userDefinedPort start=&quot;false&quot; port=&quot;874&quot;/&gt;&lt;!-- port=874 --&gt;</span><br><span class="line">	&lt;timeout start=&quot;false&quot; time=&quot;100&quot;/&gt;&lt;!-- timeout=100 --&gt;</span><br><span class="line">	&lt;ssh start=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/rsync&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 启动服务</span></span><br><span class="line">[root@nfs01 sersync-master]# sersync2 -dro /usr/local/sersync/confxml.xml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 测试实时备份功能</span></span><br><span class="line">[root@nfs01 sersync-master]# touch /data/test.txt</span><br><span class="line">[root@backup ~]# ll /backup/nfs/</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 rsync rsync  0 Dec 27 15:57 test.txt</span><br><span class="line">drwxr-xr-x 3 rsync rsync 21 Dec 25 20:06 web</span><br></pre></td></tr></table></figure>

<p><strong>备份服务器邮件服务配置</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 编辑配置文件</span></span><br><span class="line">[root@backup ~]# vim /etc/mail.rc</span><br><span class="line">set from=714616622@qq.com</span><br><span class="line">set smtp=smtp.qq.com</span><br><span class="line">set smtp-auth-user=714616622@qq.com</span><br><span class="line">set smtp-auth-password=abftwbzzphewbeah</span><br><span class="line">set smtp-auth=login</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 重启服务</span></span><br><span class="line">systemctl restart postfix.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 测试邮件功能</span></span><br><span class="line">echo &quot;xxx&quot; | mail -s &quot;标题&quot; 714616622@qq.com</span><br></pre></td></tr></table></figure>

<p><strong>web 服务器备份配置</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 创建密码文件</span></span><br><span class="line">[root@web01 ~]# echo web &gt; /etc/rsync.pas</span><br><span class="line">[root@web01 ~]# chmod 600 /etc/rsync.pas</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 创建脚本目录</span></span><br><span class="line">[root@web01 ~]# mkdir /scripts</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 创建脚本并编写</span></span><br><span class="line">[root@web01 ~]# vim /scripts/web_backup.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> RSYNC_PASSWORD=web</span></span><br><span class="line">date_info=$(date &quot;+%F_%A&quot; -d &quot;-1 day&quot;) # 备份时间信息</span><br><span class="line">bak_dir=&quot;/backup/web/$(/usr/sbin/ip a s eth1 | awk -F &quot;[ /]+&quot; &#x27;NR==3&#123;print $3&#125;&#x27;)&quot; # 备份目标目录(后面不加/的原因是需要在rsync备份时将目录及其子文件传输)</span><br><span class="line">bak_system_data=&quot;/etc/profile /etc/fstab /etc/php-fpm.d/www.conf /etc/php.ini /etc/exports /etc/logrotate.d/nginx /etc/keepalived/keepalived.conf /etc/nginx/nginx.conf /etc/nginx/conf.d/&quot; # 备份数据列表(系统文件)</span><br><span class="line">bak_web_code=&quot;/html/&quot; # 备份数据列表(代码文件)</span><br><span class="line">bak_web_log=&quot;/var/log/nginx/&quot; # 备份数据列表(日志文件)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建目录</span></span><br><span class="line">if [ ! -d $bak_dir ]</span><br><span class="line">then</span><br><span class="line">    mkdir -p $bak_dir</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 压缩数据</span></span><br><span class="line">tar zcfh $bak_dir/system_data_$&#123;date_info&#125;.tar.gz $bak_system_data</span><br><span class="line">tar zcfh $bak_dir/web_code_$&#123;date_info&#125;.tar.gz $bak_web_code</span><br><span class="line">tar zcfh $bak_dir/web_log_$&#123;date_info&#125;.tar.gz $bak_web_log &amp;&gt; /dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除七天前的数据</span></span><br><span class="line">find $bak_dir -type f -name &quot;*.tar.gz&quot; -mtime +7 -delete</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据校验</span></span><br><span class="line">find $bak_dir -type f -name &quot;*.tar.gz&quot; -mmin -200 | xargs md5sum &gt; $bak_dir/check.pw</span><br><span class="line"><span class="meta">#</span><span class="bash"> rsync 备份</span></span><br><span class="line">rsync -az $bak_dir web@10.0.0.41::web_bak --password-file=/etc/rsync.pas</span><br></pre></td></tr></table></figure>

<p><strong>备份服务器代码</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 创建脚本目录</span></span><br><span class="line">[root@backup ~]# mkdir /scripts</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 创建脚本并编写</span></span><br><span class="line">[root@backup ~]# vim /scripts/backup.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据完整性校验</span></span><br><span class="line">find /backup -type f -name &quot;check.pw&quot; | xargs md5sum -c &gt; /var/log/Integrity_check</span><br><span class="line"><span class="meta">#</span><span class="bash"> 邮件发送</span></span><br><span class="line">mail -s &quot;备份数据日志&quot; 714616622@qq.com &lt; /var/log/Integrity_check</span><br><span class="line"><span class="meta">#</span><span class="bash"> 保留每周一的所有数据副本，其他保留6个月的数据副本</span></span><br><span class="line">find /backup -type f ! -name &quot;*Monday.tar.gz&quot; -mtime +180 -name -delete</span><br></pre></td></tr></table></figure>

<p><strong>配置定时任务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@web01 ~]# crontab -e</span><br><span class="line">00 18 * * * /bin/sh /scripts/web_backup.sh &amp;&gt; /dev/null</span><br><span class="line">[root@backup ~]# crontab -e</span><br><span class="line">01 18 * * * /bin/sh /scripts/backup.sh &amp;&gt; /dev/null</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
