<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NFS 服务部署</title>
    <url>/2020/12/14/NFS%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="一-存储服务初识"><a href="#一-存储服务初识" class="headerlink" title="一. 存储服务初识"></a>一. 存储服务初识</h3><p><strong>NFS 存储服务概念说明</strong></p>
<p>NFS 是 Network File System 的缩写，即网络文件系统，其主要功能是通过网络 (一般为局域网) 让不同的主机之间可以共享文件或目录。</p>
<p>NFS 客户端 (一般为应用服务器，例如 web) 可以通过挂载 (mount) 的方式将 NFS 服务端共享的数据目录挂载到 NFS 客户端本地系统中。从客户端本地看，NFS 服务器端共享的目录就好像是客户端自己的磁盘分区或者目录一样，但实际访问的是 NFS 服务器的目录。</p>
<p>第一个网络文件系统被称为 File Access Listener，由 Digital Equipment Corporation (DEC) 在 1976 年开发。NFS 是第一个构建于 IP 协议之上的现代网络文件系统。</p>
<p><strong>NFS 存储服务的作用</strong></p>
<p>对于多台网站服务器，经过负载均衡调度之后用户数据分别上传到不同 web 服务器磁盘中时会出现数据不一致的问题 。</p>
<p>如果对多台 web 服务器均进行实时无差异的数据同步，部署会很麻烦，并且浪费磁盘空间。存储服务器的出现可以实现数据存储的统一性(即共享)，也可以节省架构服务器磁盘的成本开销(web服务器磁盘只需满足系统安装即可，存储服务器按需进行磁盘扩容)。</p>
<p><strong>NFS 存储服务的应用</strong></p>
<p>对于中小型企业，采用 NFS 或者 Samba 即可充分满足数据存储的应用。对于中大型企业，建议采用分布式存储MooseFS(mfs)、GlusterFS、FastDFS或者专业硬件存储 EMC (戴尔)。</p>
<p>在企业集群架构的工作场景中，NFS 网络文件系统一般被用来存储共享视频、图片、附件等静态资源文件，通常网站用户上传的文件都会放在 NFS 共享里。</p>
<p>共享存储的位置可以通过开源软件和商业硬件实现，互联网中小型集群架构会用普通 PC 服务器配置 NFS 网络文件系统实现。硬件实现可以利用 IOE(IBM Oracle EMC) 相应的硬件设备实现，但去 IOE 正在成为互联网公司的主流。</p>
<p><strong>NFS 在网络文件共享服务作用总结</strong></p>
<ol>
<li>负载均衡设备会将访问流量进行分流，不便于文件和数据的互相访问 ；</li>
<li>利用服务器间的数据同步可以实现用户之间数据互访，但同步管理操作过于复杂 ；</li>
<li>利用 NFS 服务器可以统一管理数据，使得用户之间可以顺利互访。</li>
</ol>
<h3 id="二-NFS-工作原理"><a href="#二-NFS-工作原理" class="headerlink" title="二. NFS 工作原理"></a>二. NFS 工作原理</h3><p><strong>实现原理</strong></p>
<p>首先存储服务器需要与客户端建立网络连接，之后实现挂载，此时数据存储到客户端挂载点目录时，实际上会通过网络传输存储到存储服务器对应的目录中。数据存储时属主和属组信息可能会发生变化，需要注意存储目录的权限。</p>
<p><strong>RPC 服务</strong></p>
<p>NFS 传输数据时使用的端口会随机选择，其中CentOS 5.x 的随机端口都小于 1024，而 CentOS 6.x 的随机端口都是较大的。NFS 客户端通过 RPC (中文意思是远程过程调用，英文 Remote Procedure Call 简称 RPC) 协议/服务来与服务端进行连接以此提供服务。</p>
<p>NFS 的 RPC 服务主要的功能就是记录每个 NFS 功能所对应的端口号，并且在 NFS 客户端请求时将该端口和功能对应的信息传递给请求数据的 NFS 客户端，从而确保客户端可以连接到正确的 NFS 端口上，达到实现数据传输交互的目的。</p>
<p>当 NFS 服务器端启动服务时会随机取用若干端口，并主动向 RPC 服务注册取用的相关端口及功能信息，RPC 服务就知道 NFS 每个端口对应的 NFS 功能了，然后 RPC 服务使用固定的 111 端口来监听 NFS 客户端提交的请求，并将正确的 NFS 端口信息回复给请求的 NFS客户端。</p>
<p>在启动 NFS Server 之前，首先要启动 RPC 服务 (Centos 5.8 下为 portmap 服务，Centos 6.6下为 rpcbind 服务)。如果 RPC 服务重新启动，原来已经注册好的 NFS 端口数据就会丢失，因此，此时 RPC 服务管理的 NFS 程序也需要重新启动以重新向 RPC 注册。</p>
<p>一般修改 NFS 配置文件后，是不需要重启 NFS 的，直接在命令行执行 <code>exportfs -rv</code> 即可使修改的 <code>/etc/exports</code> 生效。</p>
<p><strong>NFS 访问存取原理</strong></p>
<ol>
<li>首先用户访问网站程序，由程序在 NFS 客户端上发出存取 NFS 文件的请求，这时 NFS 客户端 (即执行程序的服务器) 的 RPC 服务 (rpcbind 服务) 就会通过网络向 NFS 服务器端的 RPC 服务 (rpcbind 服务) 的 111 端口发出 NFS 文件存取功能的询问请求。</li>
<li>NFS 服务器端的 RPC 服务 (rpcbind 服务) 找到对应的已注册的 NFS 端口后，通知 NFS客户端的 RPC 服务 (rpcbind 服务) 。</li>
<li>此时 NFS 客户端获取到正确的端口，并与 NFS daemon 联机存取数据。</li>
<li>NFS 客户端把数据存取成功后，返回给前端访问程序，告知用户存取结果，作为网站用户，就完成了一次存取操作。</li>
<li>总结：NFS 需要有 RPC 服务的协助才能成功对外提供服务。要使用 NFS 时，都需要首先启动 RPC 服务，NFS 服务必须在 RPC 服务启动之后启动，客户端无需启动 NFS 服务，但需要启动 RPC 服务。</li>
</ol>
<p><strong>NFS 服务常见进程详解</strong></p>
<p>运行 NFS 服务默认需要启动的服务或进程至少有：NFS quotas (rpc.rquotad) ，NFS daemon (nfsd) ，NFS mount (rpc.mountd) 。</p>
<p>NFS 服务的主要任务是共享文件系统数据，而文件系统数据的共享离不开权限问题。所以NFS 服务器启动时最少需要两个不同的进程，一个是管理 NFS 客户端是否能够登入的 rpc.nfsd 主进程，另一个用于管理 NFS 客户端是否能够取得对应权限的 rpc.mountd 进程。如果还需要管理磁盘配额，则 NFS 还要再加载 rpc.rquotad 进程。</p>
<h3 id="三-NFS-部署"><a href="#三-NFS-部署" class="headerlink" title="三. NFS 部署"></a>三. NFS 部署</h3><p><strong>服务端(172.16.1.31)部署过程：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 安装软件</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 创建用于存储的目录，同时调整属主属组信息</span></span><br><span class="line">mkdir /data</span><br><span class="line">chown nfsnobody. /data</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 补充，为了配置方便，可以先进行 hosts 配置</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line">172.16.1.7  web01 # 将其写入到 /etc/hosts 文件中</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 编写配置文件 /etc/exports ，默认为空，可以通过 man exports 来查看如何配置</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/data web01(rw,sync) backup(rw,sync) # 将其写入到 /etc/exports 文件中</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 启动服务</span></span><br><span class="line">systemctl start nfs.service</span><br></pre></td></tr></table></figure>

<p><strong>客户端(172.16.1.7)部署过程：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 安装软件(目的是让客户端识别 nfs 文件系统类型以实现挂载)</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 创建挂载点，进行本地目录挂载</span></span><br><span class="line">mkdir /upload</span><br><span class="line">mount -t nfs 172.16.1.31:/data /upload</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>

<p><strong>客户端挂载参数提升：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t nfs -o fg,hard,intr,rsize=131072,wsize=131072 10.0.0.7:/data /mnt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. <span class="built_in">fg</span> 代表客户端执行挂载时在前台执行，此时 mount 会持续尝试挂载直到成功或挂载时间超时</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. hard 使用 hard 模式挂载时，client 会一致尝试连接到 server，此时无法 umount 或者 <span class="built_in">kill</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 当使用 hard 挂载 timeout 时，如果指定 intr 参数可以在 timeout 后中断，避免出现问题时系统被 NFS 锁死</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. rsize 和 wsize 为性能参数，分别代表读出和写入的区块大小，可以提升传输能力。rsize 和 wsize 的大小最好是 1024 的倍数</span></span><br></pre></td></tr></table></figure>

<p><strong>客户端挂载参数优化 (mount 挂载优化内容)：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有关系统安全挂载参数选项</span></span><br><span class="line">mount -t nfs -o nosuid,noexec,nodev,rw 10.0.0.7:/data /mnt</span><br><span class="line"><span class="comment"># 禁止更新目录及文件时间戳挂载</span></span><br><span class="line">mount -t nfs -o noatime,nodiratime 10.0.0.7:/data /mnt</span><br><span class="line"><span class="comment"># 安全加优化的挂载方式</span></span><br><span class="line">mount -t nfs -o nosuid,noexec,nodev,noatime,nodiratime,rsize=131072,wsize=131072 10.0.0.7:/data /mnt</span><br></pre></td></tr></table></figure>

<h3 id="四-NFS-配置文件与配置参数详解"><a href="#四-NFS-配置文件与配置参数详解" class="headerlink" title="四. NFS 配置文件与配置参数详解"></a>四. NFS 配置文件与配置参数详解</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> NFS 默认配置文件路径为 /etc/exports，内容为空，需要用户自行配置</span> </span><br><span class="line">man exports # 查看官方配置说明文档，内容见下</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> sample /etc/exports file</span></span><br><span class="line">/               master(rw) trusty(rw,no_root_squash)</span><br><span class="line">/projects       proj*.local.domain(rw)</span><br><span class="line">/usr            *.local.domain(ro) @trusted(rw)</span><br><span class="line">/home/joe       pc001(rw,all_squash,anonuid=150,anongid=100)</span><br><span class="line">/pub            *(ro,insecure,all_squash)</span><br><span class="line">/srv/www        -sync,rw server @trusted @external(ro)</span><br><span class="line">/foo            2001:db8:9:e54::/64(rw) 192.0.2.0/24(rw)</span><br><span class="line">/build          buildhost[0-9].local.domain(rw)</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># 每一行分为三个部分</span></span><br><span class="line"><span class="comment"># 1. 指定本地存储数据的目录</span></span><br><span class="line"><span class="comment"># 2. 定义允许存储数据的主机信息，可以是ip地址、网段、主机名(需要提前进行 hosts 配置)</span></span><br><span class="line"><span class="comment"># 3. 存储服务参数配置，比较常用的有 rw、sync</span></span><br><span class="line"><span class="comment"># 总结：服务端存储目录 客户端主机1ip(参数) 客户端主机2ip(参数)</span></span><br></pre></td></tr></table></figure>

<p>关于 no_all_squash 的说明：假设客户端使用 linus 进行管理，如果存储服务器上不存在 linus 用户，则在存储服务器上 linus 的数据使用 linus 的 uid 和 gid 进行管理；如果存储服务器上虽然没有 linus 用户，但是存在 uid 与linus 一样的用户 zeus，那么 linus 的数据在存储服务器上使用 zeus 进行管理。</p>
<p><strong>参数配置图解说明如下</strong></p>
<p><img src="https://zeuslb.github.io/img/NFS%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%94%A8%E6%88%B7%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86%E5%9B%BE.svg" alt="NFS客户端用户映射原理图"></p>
<p><strong>NFS 客户端地址的配置详细说明见下</strong></p>
<table>
<thead>
<tr>
<th>客户端地址</th>
<th>具体地址</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>授权单一客户端访问 NFS</td>
<td>10.0.0.30</td>
<td>一般情况，生产环境中此配置不多</td>
</tr>
<tr>
<td>授权整个网段可访问 NFS</td>
<td>10.0.0.0/24</td>
<td>其中的 24 等同于 255.255.255.0，指定网段为生产环境中最常见的配置。配置简单，维护方便</td>
</tr>
<tr>
<td>授权整个网段可访问 NFS</td>
<td>10.0.0.*</td>
<td>指定网段的另外写法 (不推荐使用）</td>
</tr>
<tr>
<td>授权某个域名客户端访问</td>
<td>nfs.linus.com</td>
<td>此方法生产环境中一般情况不常用</td>
</tr>
<tr>
<td>授权整个域名客户端访问</td>
<td>*.linus.com</td>
<td>此方法生产环境中一般情况不常用</td>
</tr>
</tbody></table>
<p><strong>NFS 配置参数权限说明见下：</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>rw (常用)</td>
<td>指定存储目录具有读写权限</td>
</tr>
<tr>
<td>ro</td>
<td>指定存储目录具有只读权限，应用场景：对于开发人员管理的服务器 (一般为测试服务器) 进行挂载操作时设置 ro 权限</td>
</tr>
<tr>
<td>sync (常用)</td>
<td>数据同步传输，会将数据直接存储到 nfs 服务器的磁盘上 (针对中小型实际 NFS 应用场景，推荐)</td>
</tr>
<tr>
<td>async</td>
<td>数据异步传输，会将数据先存储到 nfs 服务器的内存中，之后定时定量地写入到磁盘上，存在安全问题</td>
</tr>
<tr>
<td>all_squash</td>
<td>将所有用户生成的数据转换为虚拟用户 nfsnobody (uid 和 gid 默认为 65534) 进行管理</td>
</tr>
<tr>
<td>no_all_squash (默认)</td>
<td>不对所有用户生成的数据进行属主和属组的转换</td>
</tr>
<tr>
<td>root_squash (默认)</td>
<td>将 root 用户生成的数据转换为虚拟用户 nfsnobody 进行管理</td>
</tr>
<tr>
<td>no_root_squash</td>
<td>不对 root 用户生成的数据进行属主和属组的转换</td>
</tr>
<tr>
<td>anonuid</td>
<td>将权限压缩为指定 uid 用户的权限，使用时在配置参数中指定 anonuid=888</td>
</tr>
<tr>
<td>anongid</td>
<td>将权限压缩为指定 gid 用户的权限，使用时在配置参数中指定 anongid=888</td>
</tr>
</tbody></table>
<p>配置好 NFS 服务后，通过 <code>cat /var/lib/nfs/etab</code> 命令可以看到 NFS 配置的参数以及默认自带的参数。</p>
<h3 id="五-错误排查"><a href="#五-错误排查" class="headerlink" title="五. 错误排查"></a>五. 错误排查</h3><p><strong>配置文件错误排查</strong></p>
<p>使用 exportfs -rv 重新加载配置文件，如果发生错误即可显示出具体的错误信息。</p>
<p>如果挂载时出现 <code>access denied by server while mounting ...</code> 时，可能的错误是配置文件错误。</p>
<p><strong>rpcbind 错误排查</strong></p>
<p>客户端挂载无反应，可能出现的问题是 rpcbind 服务程序(远程过程调用程序)未启动(启动：systemctl start rpcbind)。当两台主机进行远程通讯时，必须的信息包括了ip地址和端口号，但是有些程序比如 nfs 会存在多端口、端口经常变化或者无端口的情况，这时可能会出现远程连接不上的问题。rpcbind 服务可以解决此问题，固定端口是 111，在进行远程时会进行统一管理进行连接。</p>
<p>如果出现 <code>RPC: Program not registered</code> 错误提示，一般是 RPC 服务和 NFS 的服务启动顺序错误，重启即可。</p>
<p>可以通过 rpcinfo -p localhost (服务端) 、rpcinfo -p 172.16.1.31 (客户端) 查看 NFS 服务是否在 RPC 上注册成功 (注册成功即 NFS 部署成功，且启动顺序无问题)。</p>
<p><strong>防火墙问题</strong></p>
<p>客户端执行 <code>showmount -e  172.16.1.31</code> 可以检查是否有可以挂载信息，如果遇到以下报错信息，大多数是因为防火墙问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@web ~]# showmount -e  172.16.1.31</span><br><span class="line">clnt_create: RPC: Port mapper failure - Unable to receive: errno 113 (No route to host)</span><br></pre></td></tr></table></figure>

<p><strong>卸载设备问题排查</strong></p>
<p>卸载挂载设备时显示 <code>device is busy</code> 时，有可能是当前目录就是挂载的 NFS 目录，也有可能是 NFS Server 挂了。对于第二种情况，只能采用 <code>umount -lf /mnt</code> (其中的参数-f 为强制卸载，参数-l 为懒惰的卸载) 进行强制卸载。</p>
<p><strong>其他错误排查</strong></p>
<p>客户端挂载错误，可能出现的问题是 hosts 配置错误，需要注意 hosts 配置更改后需要重新启动 nfs.service 服务。</p>
<h3 id="六-NFS-存储服务常见问题说明"><a href="#六-NFS-存储服务常见问题说明" class="headerlink" title="六. NFS 存储服务常见问题说明"></a>六. NFS 存储服务常见问题说明</h3><p><strong>自动挂载问题说明：</strong></p>
<p>因为临时挂载时，重启服务器会失效，所以需要实现自动挂载，配置如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/fstab</span><br><span class="line">172.16.1.31:/data /upload nfs default 0 0</span><br></pre></td></tr></table></figure>

<p>根据系统启动流程，fstab 文件是在网络服务启动之前进行加载的，之所以挂载成功，是因为网络服务启动之后，会自动启动一个叫作 <code>remote-fs.target</code> 的服务，该服务会重新扫描 fstab 文件进行挂载，从而实现网络存储服务的挂载。</p>
<p>自动挂载也可以使用将挂载命令放到 <code>/etc/rc.local</code> 文件中。其缺点是偶尔可能出现开机挂载不上的问题，在实际工作环境下，处理开机自启动配置，还要对是否挂载进行监控。</p>
<p><strong>共享目录挂载时很卡问题说明：</strong></p>
<p>NFS 服务端重启之后。立刻进行挂载会出现此问题，因为 NFS 自身重启的时候，拥有无敌的时间，默认是 90 秒；在无敌时间内，是不能对共享目录进行更改的操作。</p>
<p>可以在系统配置 <code>/etc/sysconfig/nfs</code> 中指定了无敌时间的配置参数 (不推荐)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NFSD_V4_GRACE=90</span><br><span class="line">NFSD_V4_LEASE=90</span><br><span class="line">NLM_GRACE_PERI0D=90</span><br></pre></td></tr></table></figure>

<p>服务程序建议尽量平滑重启，即使用 <code>reload</code>，而不是 restart 。</p>
<p><strong>出现文件句柄错误说明：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount.nfs: Stale file handle</span><br></pre></td></tr></table></figure>

<p>配置改变后，客户端没有进行卸载而是直接使用挂载点，解决方案为卸载后重新进行挂载即可。</p>
<p><strong>存储服务器中创建存储目录不要有父级与子级关系说明</strong></p>
<p>如果有父子关系出现，可能的现象有父级目录可以让子级目录所指定的主机进行挂载、父级目录设置权限参数会有集成关系等。</p>
<h3 id="七-更多参考资料"><a href="#七-更多参考资料" class="headerlink" title="七. 更多参考资料"></a>七. 更多参考资料</h3><ul>
<li><a href="http://www.citi.umich.edu/projects/nfsv4/linux/">http://www.citi.umich.edu/projects/nfsv4/linux/</a></li>
<li><a href="http://www.vanemery.com/Linux/NFSv4/NFSv4-no-rpcsec.html">http://www.vanemery.com/Linux/NFSv4/NFSv4-no-rpcsec.html</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-network-filesystems/">http://www.ibm.com/developerworks/cn/linux/l-network-filesystems/</a></li>
<li><a href="http://www.tldp.org/HOWTO/NFS-HOWTO/index.html">http://www.tldp.org/HOWTO/NFS-HOWTO/index.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx 部署与使用(一)</title>
    <url>/2020/12/16/Nginx%20%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8(%E4%B8%80)/</url>
    <content><![CDATA[<h3 id="一-Nginx-部署"><a href="#一-Nginx-部署" class="headerlink" title="一. Nginx 部署"></a>一. Nginx 部署</h3><p><strong>部署方式一：官方源安装</strong></p>
<p>使用官方源安装的目录结构会比较标准，同时可以下载最新的稳定版。</p>
<ol>
<li><p>更新 yum 下载源(nginx 官方网站：nginx.org)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 官方参考 http://nginx.org/en/linux_packages.html<span class="comment">#RHEL-CentOS</span></span></span><br><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载安装软件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y nginx</span><br><span class="line">nginx -V</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>部署方式二：编译安装</strong></p>
<ol>
<li><p>解决依赖问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y pcre-devel openssl-devel</span><br><span class="line"><span class="meta">#</span><span class="bash"> pcre-devel 可以实现兼容 perl 语言的正则表达式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> openssl-devel 可以实现基于 HTTPS 协议的数据传输</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建服务进程管理用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd nginx -M -s /sbin/nologin</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载编译安装源码包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.18.0.tar.gz</span><br><span class="line">tar xf nginx-1.18.0.tar.gz</span><br><span class="line">cd nginx-1.18.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译安装</p>
<ul>
<li><p>配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --help</span><br><span class="line"><span class="meta">#</span><span class="bash"> 常见参数说明</span></span><br><span class="line">--prefix=PATH # 指定软件程序的安装路径 /app/nginx-1.18.0</span><br><span class="line">--sbin-path=PATH # 软件有关命令文件的保存路径 /usr/bin</span><br><span class="line">--modules-path=PATH # 软件生成的模块保存路径</span><br><span class="line">--conf-PATH # 软件配置文件保存路径</span><br><span class="line">--error</span><br><span class="line">--with-xxx # 可以使用的功能模块</span><br><span class="line">--without-xxx # 指定不使用的功能模块</span><br><span class="line">./configure  --prefix=/app/nginx-1.18 --user=nginx --group=nginx  --with-http_ssl_module  --with-http_stub_status_module</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>网络通讯与 HTTP</title>
    <url>/2020/12/15/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8E%20HTTP/</url>
    <content><![CDATA[<h3 id="一-网站服务通讯过程"><a href="#一-网站服务通讯过程" class="headerlink" title="一. 网站服务通讯过程"></a>一. 网站服务通讯过程</h3><p><strong>网站服务通讯过程原理(简易版)</strong></p>
<p>首先用户在浏览器中输入域名，然后会进行 DNS 解析。获取到 IP 地址后，客户端和服务端通过 TCP 三次握手建立连接，然后客户端发送请求，服务端进行响应，最后会经过四次挥手断开连接。</p>
<p><strong>网站服务通讯过程原理/HTTP 协议请求的工作流程(描述版)</strong></p>
<ol>
<li>终端用户在 Web 浏览器地址栏输入访问地址 <a href="http://www.baidu.com/">www.baidu.com</a> 。</li>
<li>Web 浏览器请求 DNS 服务器把域名 <a href="http://www.baidu.com/">www.baidu.com</a> 转换为 Web 服务器的 IP 地址。</li>
<li>Web 浏览器将端口号 (默认 80) 从访问地址 (URL) 中解析出来。</li>
<li>Web 浏览器通过解析后的 IP 地址及端口号与 Web 服务器之间建立一条 TCP 连接 (三次握手)。</li>
<li>建立 TCP 连接后，Web 浏览器向 Web 服务器发送一条 HTTP 请求报文。</li>
<li>Web 服务器响应并读取浏览器的请求信息，然后返回一条 HTTP 响应报文。</li>
<li>Web 服务器关闭 HTTP 连接，关闭 TCP 连接，Web 浏览器显示访问的网站内容到屏幕上。</li>
</ol>
<p><strong>Windows 主机查看 DNS 的相关方式</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 Windows 本地缓存的 DNS 解析记录</span></span><br><span class="line">ipconfig /displaydns</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除 Windows 本地缓存的 DNS 解析记录</span></span><br><span class="line">ipconfig /flushdns</span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows 系统下 hosts 域名解析记录的位置：C:\Windows\system32\drivers\etc\hosts</span></span><br></pre></td></tr></table></figure>

<h3 id="二-DNS-介绍"><a href="#二-DNS-介绍" class="headerlink" title="二. DNS 介绍"></a>二. DNS 介绍</h3><p><strong>DNS 概念与作用</strong></p>
<p>DNS，全称为 Domain Name System ，其主要作用是把网站域名解析为对应的 IP 地址。从域名到 IP 的解析过程，称作 A 记录，即 Address Record。除了 A 记录解析，DNS 还可以完成很多功能，例如：</p>
<ul>
<li>设置 CNAME 别名记录，这个别名解析功能常被 CDN 加速服务商应用。</li>
<li>设置 MX 邮件记录，这个 MX 记录功能，在购买或搭建邮件服务时会被用到。</li>
<li>设置 PTR 记录，反向解析，即把 IP 地址解析为对应的域名，和 A 记录的解析相反，此功能在邮件服务等业务中会用到。</li>
<li>…</li>
</ul>
<p>DNS 系统的架构类似于一颗倒挂着的树，顶点是根，用 <code>.</code> 来表示。DNS 进行域名解析时是从后往前进行解析的。</p>
<p><strong>DNS 解析流程</strong></p>
<ol>
<li>客户端用户在浏览器里输入 <a href="http://www.baidu.com/">www.baidu.com</a> 网站地址后回车，系统首先会查找系统本地的 DNS 缓存及 hosts 文件信息，确定是否存在 <a href="http://www.baidu.com/">www.baidu.com</a> 域名对应的 IP解析记录，如果有就直接获取到 IP 地址，然后去访问这个 IP 地址对应的 <a href="http://www.baidu.com/">www.baidu.com</a> 域名的服务器。一般第一次请求时，DNS 缓存是没有解析记录的，而 hosts 多为内部临时测试使用。</li>
<li>如果客户端本地 DNS 缓存及 hosts 文件没有 <a href="http://www.baidu.com/">www.baidu.com</a> 域名对应的解析记录，那么系统会把浏览器的解析请求发送给客户端本地设置的 DNS 服务器地址 (通常称此 DNS 为 LDNS，即 Local DNS) 解析，如果 LDNS 服务器的本地缓存有对应的解析记录就会直接返回 IP 地址给客户端，如果没有，则 LDNS 会负责继续请求其他的 DNS 服务器。</li>
<li>LDNS 从 DNS 系统的(“.”)根开始请求对 <a href="http://www.baidu.com/">www.baidu.com</a> 域名的解析，根 DNS 服务器在全球一共有 13 台，根服务器下面是没有 <a href="http://www.baidu.com/">www.baidu.com</a> 域名解析记录的，但是根下面有 <a href="http://www.baidu.com/">www.baidu.com</a> 对应的顶级域 .com 的解析记录，因此，根会把.com 对应的 DNS 服务器地址返回给 LDNS。</li>
<li>LDNS 获取到 .com 对应的 DNS 服务器地址后，就会去 .com 服务器请求 <a href="http://www.baidu.com/">www.baidu.com</a> 域名的解析，而 .com 服务器下面也没有 <a href="http://www.baidu.com/">www.baidu.com</a> 域名对应的解析记录，但是有 baidu.com 域名的解析记录，因此 .com 服务器会把 baidu.com 对应的 DNS 服务器地址返回给 LDNS。</li>
<li>同理，LDNS 获取到 baidu.com 对应的 DNS 服务器地址后，会去 baidu.com服务器请求对 <a href="http://www.baidu.com/">www.baidu.com</a> 域名的解析，baidu.com 域名对应的 DNS 服务器是该域名的授权 DNS 服务器，这个 DNS 服务器是企业购买域名时用于管理解析的服务器 (也可能是自建的授权 DNS 服务器) ，这个服务器会有与 <a href="http://www.baidu.com/">www.baidu.com</a> 对应的 IP 解析记录，如果此时没有，就表示企业的域名人员没有为 <a href="http://www.baidu.com/">www.baidu.com</a> 域名做解析，即网站还没架设好。</li>
<li>LDNS 把来自授权 DNS 服务器的与 <a href="http://www.baidu.com/">www.baidu.com</a> 对应的 IP 解析记录发给客户端浏览器，并且 LDNS 会在本地把域名和 IP 的对应解析记录缓存起来，以便下一次更快地返回相同解析请求的记录。至此，整个 DNS 的解析流程就完成了。</li>
</ol>
<h3 id="三-HTTP-协议"><a href="#三-HTTP-协议" class="headerlink" title="三. HTTP 协议"></a>三. HTTP 协议</h3><p><strong>HTTP 协议初识</strong></p>
<p>HTTP 协议，全称 HyperText Transfer Protocol，中文名为超文本传输协议。是互联网上常用的通信协议之一。它有很多的应用，但最流行的就是用于 Web 浏览器和 Web 服务器之间的通信，即 www 应用或称 Web 应用。</p>
<p>HTTP 协议属于 OSI 模型中的第七层应用层协议。</p>
<p>HTTP 协议的 www 服务应用的默认端口为 80，另外一个加密的 www 服务应用 HTTPS 的默认端口为 443，主要用于网银、支付等和钱相关的业务。</p>
<p><strong>HTTP 协议版本</strong></p>
<p>HTTP/0.9 是 HTTP 协议的第一个版本，仅适用于数据信息的简介交换，即仅文本传输。只接受 GET 这一种请求方式，且不支持请求头，由于不支持 POST 方式，大多数敏感信息无法交换，至此客户端无法向服务器传递过多信息。缺点是信息种类过于单一，无法满足需求，串行处理。</p>
<p>HTTP/1.0 支持 Cache、MIME、Method ，引入了 POST 和 HEAD 命令，在一定程度上提升了数据的传输安全，是一个典型的串行连接事务。1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后即断开 TCP 连接，即不支持 keepalive 。服务器不跟踪每个客户，也不记录过去的请求。缺点是串行处理，效率低下。</p>
<p>HTTP/1.1 是当前互联网主流的 HTTP 版本。引入了持久连接机制并被默认采用，且能更好地配合代理服务器工作，还支持管道方式同一连接下同时发送多个请求，以降低线路负载，提高传输速度。新增方法有 PUT、PATCH、OPTIONS、DELETE 。缺点是同一 TCP 连接里，所有通信按次序进行，服务器只能顺序处理回应，如果前面处理过慢，会有许多请求排队，造成队头阻塞 (Head-of-line blocking) 。</p>
<p>HTTP/2.0 的头信息和数据体都是二进制，称为头信息帧和数据帧。2.0 可以复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了”队头堵塞”，该双向的实时通信称为多工 (Multiplexing)。2.0 引入了头信息压缩机制 (header compression)，头信息使用 gzip 或 compress 压缩后再发送。2.0  也允许服务器未经请求，主动向客户端发送资源，即服务器推送 (server push) 。</p>
<p><strong>HTTP 请求方法</strong></p>
<p>在 HTTP 通信中，每个 HTTP 请求报文都包含一个方法，用以告诉 Web 服务器端需要执行哪些具体的动作。这些动作包括获取指定 Web 页面、提交内容到服务器、删除服务器上资源文件等。这些 HTTP 请求报文中包含的方法被称为 HTTP 请求方法。常见的 HTTP 请求方法见下：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">GET</td>
<td align="left">获取 URI 指定的信息。如果 URI 指定的是文件，则返回文件的内容；如果 URI 指定的是 CGI 程序，则返回该程序的输出数据</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">HEAD</td>
<td align="left">和 GET 基本相同。不过它只返回 HTTP 的消息头 (message header) ，而并不返回数据的内容。用于获取文件最后更新时间等属性信息</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">POST</td>
<td align="left">从客户端向服务器发送数据。一般用于发送表单中填写的数据、上传文件等情况下</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">PUT</td>
<td align="left">替换 URI 指定的服务器上的文件。如果 URI 指定的文件不存在，则创建该文件</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">DELETE</td>
<td align="left">删除 URI 指定的服务器上的文件</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">CONNECT</td>
<td align="left">使用代理传输加密消息时使用的方法</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">OPTIONS</td>
<td align="left">允许客户端查看服务器的性能或者用于通知或查询通信选项</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">TRACE</td>
<td align="left">将服务器收到的请求行和头部 (header) 直接返回给客户端。用于在使用代理的环境中检查改写请求的情况 (即多用于测试)</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">PATCH</td>
<td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新</td>
</tr>
</tbody></table>
<p><strong>HTTP 状态码</strong></p>
<p>HTTP 状态码 (HTTP Status Code) 是用来表示 Web 服务器响应 HTTP 请求状态的数字代码。每当 Web 客户端向 Web 服务器发送一个 HTTP 请求时，Web 服务器都会返回一个状态响应代码。这个状态码是一个三位数字代码，作用是告知 Web 客户端此次请求是否成功，或者是否要采取其他的动作方式。</p>
<p>常见的状态码分类见下：</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">分类描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1**</td>
<td align="left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="left">2**</td>
<td align="left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td align="left">3**</td>
<td align="left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="left">4**</td>
<td align="left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="left">5**</td>
<td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<p>状态码速查见下：</p>
<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="left"><code>200</code></td>
<td align="left">OK</td>
<td align="left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-Authoritative Information</td>
<td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left">重置内容。服务器处理成功，用户终端 (例如：浏览器) 应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端 (例如：浏览器) 选择</td>
</tr>
<tr>
<td align="left"><code>301</code></td>
<td align="left">Moved Permanently</td>
<td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="left"><code>302</code></td>
<td align="left">Found</td>
<td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">Not Modified</td>
<td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">Unused</td>
<td align="left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="left"><code>307</code></td>
<td align="left">Temporary Redirect</td>
<td align="left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">Bad Request</td>
<td align="left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">Unauthorized</td>
<td align="left">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left">保留，将来使用</td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">Forbidden</td>
<td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="left"><code>404</code></td>
<td align="left">Not Found</td>
<td align="left">服务器无法根据客户端的请求找到资源 (网页) 。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">Method Not Allowed</td>
<td align="left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">Request Time-out</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-URI Too Large</td>
<td align="left">请求的URI过长 (URI通常为网址) ，服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">Requested range not satisfiable</td>
<td align="left">客户端请求的范围无效</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed</td>
<td align="left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td align="left"><code>500</code></td>
<td align="left">Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">Not Implemented</td>
<td align="left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">Bad Gateway</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">Gateway Time-out</td>
<td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version not supported</td>
<td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<p><strong>生产场景常见的状态码及其对应的作用</strong></p>
<table>
<thead>
<tr>
<th>状态代码</th>
<th>详细描述说明</th>
</tr>
</thead>
<tbody><tr>
<td>200 - OK</td>
<td>服务器成功返回网页，这是成功的 HTTP 请求返回的标准状态码</td>
</tr>
<tr>
<td>301 - Moved Permanently</td>
<td>永久跳转，所请求的网页将永久跳转到被设定的新位置，例如：从 <code>zeus.com</code> 跳转到 <code>www.linus.com</code></td>
</tr>
<tr>
<td>403 - Forbidden</td>
<td>禁止访问，虽然这个请求是合法的，但是服务器端因为匹配了预先设置的规则而拒绝响应客户端的请求，此类问题一般为服务器或服务权限配置不当所致。Nginx 403 forbidden 多种原因及故障模拟重现 (<a href="https://blog.51cto.com/oldboy/1633952)%E3%80%81apache">https://blog.51cto.com/oldboy/1633952)、apache</a> 服务 Forbidden 403 问题精彩总结 (<a href="https://blog.51cto.com/oldboy/581383">https://blog.51cto.com/oldboy/581383</a>)</td>
</tr>
<tr>
<td>404 - Not Found</td>
<td>服务器找不到客户端请求的指定页面，可能是客户端请求了服务器上不存在的资源所致。</td>
</tr>
<tr>
<td>500 - Internal Server Error</td>
<td>内部服务器错误，服务器遇到了意料不到的情况，不能完成客户的请求。这是一个较为笼统的报错，一般为服务器的设置或内部程序问题导致。例如：SELinux 开启，而又没有为 HTTP 设置规则许可，客户端访问就是 500</td>
</tr>
<tr>
<td>502 - Bad Gateway</td>
<td>坏的网关，一般是代理服务器请求后端服务时，后端服务不可用或没有完成响应网关服务器。这通常为反向代理服务器下面的节点出问题所致。反向代理服务器无法与后面的 web 服务节点服务器建立联系</td>
</tr>
<tr>
<td>503 - Service Unavailable</td>
<td>服务当前不可用，可能是服务器超载或停机维护导致的，或者是反向代理服务器后面没有可以提供服务的节点</td>
</tr>
<tr>
<td>504 - Gateway Timeout</td>
<td>网关超时，一般是网关代理服务器请求后端服务时，后端服务没有在特定的时间内完成处理请求。多数是服务器过载导致没有在指定的时间内返回数据给前端代理服务器。</td>
</tr>
</tbody></table>
<p><strong>HTTP 请求报文结构</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 模拟发送请求，查看请求与响应数据包</span></span><br><span class="line">curl -v www.jd.com # 利用 curl 命令的-v 参数，查看访问网站请求与响应信息</span><br><span class="line">wget --debug www.baidu.com # 利用 wget 命令的--debug 参数，查看访问网站请求与响应信息</span><br></pre></td></tr></table></figure>

<p>从 Web 客户端发往 Web 服务器的 HTTP 报文，称为请求报文 (Request Message) 。HTTP 请求报文由请求行、请求头部 (header) 、空行和请求报文主体几个部分组成。</p>
<p>HTTP 请求报文格式说明见下：</p>
<table>
<thead>
<tr>
<th>报文格式</th>
<th>报文信息</th>
</tr>
</thead>
<tbody><tr>
<td>请求行</td>
<td>请求方法 URL 协议版本</td>
</tr>
<tr>
<td>请求头</td>
<td>格式 → 字段名 1 : 值 1 ，主要包含一些客户端的信息说明</td>
</tr>
<tr>
<td>空行</td>
<td>空白无内容，隔离上下行，说明请求头部结束</td>
</tr>
<tr>
<td>请求报文主体</td>
<td>GET 方法没有请求报文主体，POST 方法才有</td>
</tr>
</tbody></table>
<p>请求行：请求报文的第一行，用来说明客户端想要做什么。内容有请求方法字段、URL 字段和 HTTP 协议版本字段组成，它们之间用空格分隔。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<p>第一个部分为请求方法字段，常见的有 GET 和 POST 。</p>
<p>第二个部分为 URL 字段，当有具体的请求时会包含具体的请求信息，如果没有具体请求信息时，默认首页信息作响应，即 / 。</p>
<p>第三个部分为 HTTP 协议版本字段，此处可能为不同的版本，主要有 HTTP1.0、HTTP1.1、HTTP2.0 版本。</p>
<p>请求头：请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号 <code>:</code> 分隔。请求头部的作用是通过客户端把请求的相关信息告诉给服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept：image&#x2F;gif,image&#x2F;jpeg # 媒体类型</span><br><span class="line">Accept-Language：zh-cn # 语言类型</span><br><span class="line">Accept-Encoding：gzip,deflate # 支持压缩</span><br><span class="line">User-Agent：Mozilla&#x2F;4.0(compatible;MSIE6.0;Windows NT;...) # 客户端类型</span><br><span class="line">Host: https:&#x2F;&#x2F;zeuslb.github.io&#x2F; # 访问网站的目标地址</span><br></pre></td></tr></table></figure>

<p>最后一个请求头部信息之后是一个空行，通过发送回车符和换行符，通知 Web 服务器空行以下不会有请求头部的信息了。</p>
<p>请求报文主体包含了要发送给 Web 服务器的数据信息。请求报文主体不会应用于 HTTP 的 GET 命令方法，而是应用与 POST 方法。POST 方法适用于需要客户填写表单的场合。</p>
<p><strong>HTTP 响应数据包结构</strong></p>
<p>HTTP 响应报文由起始行、响应头部 (header) 、空行和相应报文主体这几个部分组成。</p>
<p>HTTP 响应报文格式说明见下：</p>
<table>
<thead>
<tr>
<th>报文格式</th>
<th>报文信息</th>
</tr>
</thead>
<tbody><tr>
<td>起始行</td>
<td>协议及版本号、数字状态码、状态信息</td>
</tr>
<tr>
<td>响应头部</td>
<td>字段名 1：值 1</td>
</tr>
<tr>
<td>空行</td>
<td>空白无内容，隔离上下文，说明响应头部结束</td>
</tr>
<tr>
<td>响应报文主体</td>
<td>请求后服务端响应返回的数据</td>
</tr>
</tbody></table>
<p>起始行：相应报文的起始行也叫状态行，用来说明服务器响应客户端请求的状况。一般为协议及版本号、数字状态码、状态情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>

<p>响应头部：和请求报文类似，起始行的后面一般有若干个头部字段。每个头部字段都包含一个名字和一个值，两者之间用冒号分隔，头部结尾也是一个空行结束的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Server: Tengine # 告知客户端服务端使用web程序</span><br><span class="line">Content-Type: text/html # 文档的 MIME 类型</span><br><span class="line">Content-Length: 154 # 响应数据的字节大小</span><br><span class="line">Connection: keep-alive # 使用 TCP 长链接方式进行通讯</span><br><span class="line">Date: Tue, 15 Dec 2020 01:46:59 GMT # 日期</span><br><span class="line">Location: https://zeuslb.github.io/ # 指定跳转后的地址信息</span><br></pre></td></tr></table></figure>

<p>最后一个响应头部信息之后是一个空行，通过发送回车符和换行符，通知客户端空行下文无头部信息了。</p>
<p>响应报文主体：响应报文主体中装载了要返回给客户端的数据。这些数据可以是文本，也可以是二进制的 (如图<br>片、视频) 。</p>
<h3 id="四-网站服务资源类型介绍"><a href="#四-网站服务资源类型介绍" class="headerlink" title="四. 网站服务资源类型介绍"></a>四. 网站服务资源类型介绍</h3><p><strong>媒体资源</strong></p>
<p>互联网上的数据有很多不同的类型，Web 服务器会把通过 Web 传输的每个对象都打上 MIME 类型 (即 MIMEtype) 的数据格式标签。最初设计 MIME (Multipurpose Internet Mail Extension，多用途因特网邮件扩展) 是为了解决在不同的电子邮件系统之间搬移报文时存在的问题。后来 HTTP 也支持了这个功能，用它来描述数据并标记不同的数据内容类型。</p>
<p>当 Web 服务器响应 HTTP 请求时，会为每一个 HTTP 对象数据加一个 MIME 类型，当 Web 浏览器获取到服务器返回的对象时，会去查看相关的 MIME 类型，并进行相应处理。</p>
<p>MIME 类型存在与 HTTP 响应报文的响应头部信息里，它是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分割。生产场景最常见的 MIME 类型见下：</p>
<table>
<thead>
<tr>
<th>MIME 类型</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td>text/html</td>
<td>html、htm、shtml 文本类型</td>
</tr>
<tr>
<td>text/css</td>
<td>css 文本类型</td>
</tr>
<tr>
<td>text/xml</td>
<td>xml 文本类型</td>
</tr>
<tr>
<td>image/gif</td>
<td>gif 图像类型</td>
</tr>
<tr>
<td>image/jpeg</td>
<td>jpeg、jpg 图像类型</td>
</tr>
<tr>
<td>application/javascripts</td>
<td>js 文本类型</td>
</tr>
<tr>
<td>text/plain</td>
<td>txt 文本类型</td>
</tr>
<tr>
<td>application/json</td>
<td>json 文本类型</td>
</tr>
<tr>
<td>video/mp4</td>
<td>mp4 视频类型</td>
</tr>
<tr>
<td>video/quicktime</td>
<td>mov 视频类型</td>
</tr>
<tr>
<td>video/x-flv</td>
<td>flv 视频类型</td>
</tr>
<tr>
<td>video/x-ms-wmv</td>
<td>wmv 视频类型</td>
</tr>
<tr>
<td>video/x-msvideo</td>
<td>avi 视频类型</td>
</tr>
</tbody></table>
<p>可以在 Nginx 配置文件 mime.types 中查看支持的媒体类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">less /etc/nginx/mime.types</span><br></pre></td></tr></table></figure>

<p><strong>静态网页资源</strong></p>
<p>静态网页是相对于动态网页而言的，是指没有后台数据库、不含程序 (如 PHP、JSP、ASP) 、不可交互的网页。</p>
<p>静态网页资源的特点是：开发者编写的是什么，它显示的就是什么，一旦编写完成，就不会有任何改变。静态网页的维护和更新相对比较麻烦，每个不同的网页都需要单独编辑更新，静态网页一般适用于更新较少的宣传展示型网站。</p>
<p>静态网页资源的对应程序及资源文件的常见扩展名为：</p>
<ul>
<li>纯文本类程序或文件，如 .html、.htm、.xml、.shtml、.js、.css 等。</li>
<li>图片类文件或数据文档，如 .jpg、.gif、.png、.bmp、.txt、.doc、.ppt 等。</li>
<li>视频类流媒体文件，如 .mp4、.swf、.avi、.wmv、.flv 等。</li>
</ul>
<p>静态的网页的优点是网页内容是固定不变的，容易被搜索引擎收录，且网页程序在用户浏览器端解析，由于服务器端不进行解析，并且不需要读取数据库，因此服务器端可以接受更多的并发访问。</p>
<p>静态网页的缺点是开发难度大，数据变化时维护相对比较困难，且静态网页的交互性差，在程序的功能实现方面有较大的限制，比如登录、在线交谈等功能的实现。</p>
<p><strong>静态网页的架构思想</strong></p>
<p>在高并发、高访问量的场景下做架构优化，涉及的关键环节就是把动态网页转成静态网页，而不是直接请求数据库和动态服务器，并且可以把静态内容推送到前端缓存 (或 CDN) 中提供服务，这样就可以提升用户体验，节约服务器和维护成本。</p>
<p><strong>动态网页资源</strong></p>
<p>所谓的动态网页是与静态网页相对而言的，一般在动态网页网址中会有标志性的符号比如 <code>&amp;</code> 或者 <code>?</code> 等。动态网页并不是独立存在于服务器上的网页文件，当用户请求服务器上的动态程序时，服务器解析这些程序并可能通过读取数据库来返回一个完整的网页内容。</p>
<p>动态网页中的 “?” 在搜索引擎的收录方面存在一定的问题，搜索引擎一般不会从一个网站的数据库中访问全部网页，或者出于技术等方面的考虑，搜索蜘蛛一般不会去抓取网址中 “?” 后面的内容，因此在企业通过搜索引擎进行推广时，需要针对采用动态网页的网站做一定的技术处理 (伪静态技术) ，以便适应搜索引擎的抓取要求。</p>
<p><strong>动态网页的架构思想</strong></p>
<p>一般来说，静态网页的性能效率是动态网页的 10-30 倍。且动态网站效率很差，并发能力也很低，在高并发场景中，应尽可能转换成静态网页提供服务。动态转静态几乎是所有高并发网站必备的架构方案思路，也是高级架构师的职责所在。<br>此外，动态转静态也是根据业务需求设计，例如，对于更新频繁的网站，如果设计不好就可能会产生数据不一致的情况，即用户看到的数据不是网站最新的内容，而是静态的内容。</p>
<p><strong>关于静态网页和动态网页的一点说明</strong></p>
<p>从前端开发的角度来说，静态网页是指不使用 HTML5/CSS3 动画效果 或者 js 交互的网页，动态网页是指使用了上述技术的网页。</p>
<p>从整体网站架构来看，静态网页/网站指的是不使用数据库等交互性软件实现的网站，而动态网站一般均包含数据库，且实现方式除了用 html 、css 、js 等技术实现基本的页面效果外，还用到了 php 、jsp 、python 等语言与后端服务器进行了交互。</p>
<p><strong>伪静态网页</strong></p>
<p>顾名思义，伪静态就是通过某些技术 (如 rewrite) 把动态网页的 URL 地址伪装成静态网页 URL 地址。从网站的 URL 地址看，伪静态表面上看起来是静态内容 (如地址结尾带 html) ，但这其实是通过 rewrite 规则实现的 URL 地址重写。改写后的 URL 地址规范、美观，有利于搜索引擎抓取，以及提升用户访问体验。</p>
<p>伪静态网页并不能提升网站的访问效率，从理论上说还会降低网站的性能，没有动态转静态网页效率高，不过，<br>对于一些并发不是很大的网站来说，或者是硬件资源充足的网站来说，伪静态还是一个不错的功能。</p>
<p><strong>拓展：生产 Web 架构优化实战方案</strong></p>
<p><a href="http://oldboy.blog.51cto.com/2561410/736710">http://oldboy.blog.51cto.com/2561410/736710</a></p>
<p><a href="https://edu.51cto.com/course/3093.html">https://edu.51cto.com/course/3093.html</a></p>
<h3 id="五-URI、URL、URN-初识"><a href="#五-URI、URL、URN-初识" class="headerlink" title="五. URI、URL、URN 初识"></a>五. URI、URL、URN 初识</h3><p><strong>URL</strong></p>
<p>URL，全称为 Uniform Resource Location，即统一资源定位符，是因特网上标准的资源唯一地址。</p>
<p>URL 的格式/组成为 <code>协议://主机ip地址或者域名[:端口号]/资源地址</code>，其中端口号可以省略，默认为 80 。</p>
<p><strong>URI</strong></p>
<p>URI，全称为 Uniform Resource Identifier，即统一资源标识符，是一个用于标识某一互联网资源名称的字符串。URL 是 URI 命名机制的一个子集。</p>
<p><strong>URN</strong></p>
<p>Uniform Resource Name，统一资源命名，是通过名字来标识资源，比如 <code>mailto:linus@gmail.com</code> 。</p>
<p><strong>URI、URL、URN 的区别</strong></p>
<p>URI 是以一种抽象的，高层次概念定义统一资源标识，而 URL 和 URN 则是具体的资源标识的方式。URL 和 URN 都是一种 URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto 就是 URN 的一种示例。</p>
<h3 id="六-网站服务访问度量方式"><a href="#六-网站服务访问度量方式" class="headerlink" title="六. 网站服务访问度量方式"></a>六. 网站服务访问度量方式</h3><p><strong>IP</strong></p>
<p>IP (独立 IP) ，即 Internet Protocol，这里指独立 IP 数，独立 IP 数是指不同 IP 地址的计算机访问网站时被计的总次数。一般一天内 (00:00-24:00) 相同 IP 地址的客户端访问网站页面只会被计一次，记录独立 IP 的时间可为一天或一个月，目前通用的标准为 “一天” 。</p>
<p>通过独立 IP 数度量网站访问量，和实际的访问情况不是很匹配。国内的企业、学校等多数是用 NAT 上网的，一个独立 IP 背后可能有数十上百个客户端访问。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在 Nginx 服务端通过日志文件模拟实现统计 ip</span></span><br><span class="line">awk &#x27;&#123;print $1&#125;&#x27; /var/log/nginx/access.log</span><br><span class="line">uniq xxx # 对上下内容进行去重，与 sort 结合使用即可实现去重</span><br><span class="line">awk &#x27;&#123;print $1&#125;&#x27; /var/log/nginx/access.log | sort | uniq -c # 去重显示每个重复次数</span><br><span class="line">awk &#x27;&#123;print $1&#125;&#x27; /var/log/nginx/access.log | sort | uniq | wc -l # 显示总的数量</span><br></pre></td></tr></table></figure>

<p>对 IP 的度量方法见下：</p>
<ul>
<li>分析所有 Web 服务器的访问日志信息，对 IP 地址段去重后计数</li>
<li>在网站的每一个 (所有) 页面结尾，嵌入 JS 等统计程序代码，待用户加载网页后，IP 即传给统计 IP 的服务器，这种方法一般被第三方统计公司或在企业内部开发日志分析程序时使用。</li>
<li>用第三方大家比较信任的统计工具，例如：谷歌的统计 (GA) 。</li>
</ul>
<p><strong>PV</strong></p>
<p>PV (访问量) 即 Page View，中文翻译为页面浏览，即页面浏览量或点击量，不管客户端是不是相同，也不管 IP 是不是相同，用户只要访问网站页面就会被计算 PV，一次计一个 PV。</p>
<p>PV 的具体度量方法就是从客户浏览器发出一个对 Web 服务器的请求 (Request) ，Web 服务器接到这个请求后，将该请求对应的网页 (Page) 发送给浏览器，这样就产生了一个 PV。这里有一个问题，就是只要这个请求发送给了浏览器，无论这个页面是否完全打开 (或下载完成) ，都会被计数 (1 次为 1 个 PV) ，一般为了防止用户快速刷 PV，很多网站会把 PV 的统计程序放在页面的最下面。</p>
<p>用 PV 衡量网站时，PV 数反映的是浏览某网站的页面数量，每刷新一次页面也算一次。因此，可以说 PV 数与来访用户的数量成正比，但 PV 数并不是真正的页面来访者数量，而是网站被访问的页面数量，因为一个来访者可能产生多个 PV。</p>
<p>一个来访者访问网站，可能产生若干 PV 数，但是独立 IP 数就只有 1 个，因此，如果对比一个网站的独立 IP 数和 PV 数，不难看出，PV 数一定会大于等于独立 IP 数，其比例视网站的业务而定，对于分类门户，可能会达到10:1，甚至更多。</p>
<p>对 PV 的度量方法见下：</p>
<ul>
<li>分析 Web 服务的访问日志 (需要排除 JS、CSS 及各种图片的日志信息) ，只计算 HTML、PHP 等页面数量。</li>
<li>在网站的每一个页面结尾，嵌入 JS 等统计程序代码，待用户加载网页后，访问数量即传给统计 PV 的服务器，这种方法一般被第三方统计公司或企业内部开发日志分析程序时使用。</li>
<li>用第三方大家比较信任的统计工具，例如：谷歌的统计 (GA) </li>
</ul>
<p><strong>UV</strong></p>
<p>UV (独立访客) 即 Unique Visitor，同一个客户端 (PC 或移动端) 访问网站被计为一个访客。一天 (00：00-24:00) 内相同的客户端访问同一个网站只计一次 UV。UV 一般是以客户端 Cookie 等技术作为统计依据的，实际统计会有误差。</p>
<p>考虑到一台客户端计算机可能会有多人使用，因此，UV (独立访客) 实际上并不一定是独立的自然人访问。</p>
<p>对 UV 的度量方法见下：</p>
<ul>
<li>通过客户端 HTTP 请求报文分析：如果这些请求满足一些共同特征，比如来自同一个 IP 地址，且浏览器版本和操作系统版本相同，请求时间又相近等，那么就可以认为这些请求是来自于同一个客户端，那么多个页面访问也只算一个 UV。共同特征的定义是由服务器方决定的。通常，用 IP 地址+其它特征共同来定义的情况较多。但此种度量方法无法解决以下问题，例如：多个人的计算机软硬件雷同，并且是一个公司或学校的人；多个人共用一个计算机等情况。</li>
<li>通过 Cookie 鉴别：当客户端第一次访问某个网站服务器时，网站服务器会给这个客户端的计算机发出一个 Cookie，通常放在这个客户端计算机的 C 盘当中。在这个 Cookie 中会分配一个独一无二的编号，这其中会记录一些访问服务器的信息，如访问时间、访问了哪些页面等等。当你下次再访问这个服务器的时候，服务器就可以直接从你的计算机中找到上一次放进去的 Cookie 文件，并且对其进行一些更新，但那个独一无二的编号是不会变的。如果在一定时间内，服务器发现 2 个来访者对应的是一个编号，那么自然可以认为它来源于同一个来访者，于是就计算 1 个 UV。使用 Cookie 也存在一些问题，比如：有的客户端为保证更高级别的安全，关闭了 Cookie 的功能；或者是有些客户端设置了在退出页面时自动删除 Cookie，抑或你经常自己去手动删除 Cookie，那么这个方法就不那么精确了。</li>
</ul>
<p><strong>工作中用到的统计工具软件</strong></p>
<ul>
<li>网页信息统计软件-piwik<ul>
<li>pwiki 统计工具：<a href="https://matomo.org/">https://matomo.org/</a></li>
<li>pwiki 演示页面：<a href="https://piwik.org/demo">https://piwik.org/demo</a></li>
</ul>
</li>
<li>ELK 软件的使用：参考博文 <a href="http://blog.oldboyedu.com/elk/">http://blog.oldboyedu.com/elk/</a></li>
</ul>
<p><strong>并发</strong></p>
<p>并发，即网站服务器在单位时间内能够处理的最大连接数。</p>
<p>QPS (Query Per Second，每秒查询率) ：每秒查询率 QPS 是用于衡量一个特定的查询服务器在规定时间内所处理流量多少的标准。运维工作中，DNS 系统及数据库等服务的查询性能经常用每秒查询率来衡量。</p>
<p>IOPS (Input/Output Operations Per Sercond) ：IOPS 即每秒进行读写 (I/O) 操作的次数，多用于数据库等场合，衡量随机访问的性能。存储端的 IOPS 性能和主机端的 I/O 是不同的，IOPS 是指存储每秒可接受多少次主机发出的访问，主机的一次 I/O 需要多次访问存储才可以完成。</p>
<h3 id="七-网站服务初识"><a href="#七-网站服务初识" class="headerlink" title="七. 网站服务初识"></a>七. 网站服务初识</h3><p><strong>当前互联网主流 Web 服务软件</strong></p>
<ul>
<li>常用来提供静态 Web 服务的软件有如下三种：<ul>
<li>Apache：这是中小型 Web 服务的主流，Web 服务器中的老大哥。</li>
<li>Nginx：大型网站 Web 服务的主流，曾经 Web 服务器中的初生牛犊，现已长大。Nginx 的分支 Tengine (<a href="http://tengine.taobao.org/">http://tengine.taobao.org/</a>) 目前也在飞速发展。</li>
<li>Lighttpd：这是一个不温不火的优秀 Web 软件，社区不活跃，静态解析效率很高。在 Nginx 流行前，它是大并发静态业务的首选，国内百度贴吧、豆瓣等众多网站都有 Lighttpd 奋斗的身影。</li>
</ul>
</li>
<li>常用来提供动态服务的软件：<ul>
<li>PHP (FastCGI) ：大中小型网站都会使用，动态网页语言 PHP 程序的解析容器。</li>
<li>Tomcat：中小企业动态 Web 服务主流，互联网 Java 容器主流 (如 jsp、do) 。</li>
<li>Resin：大型动态 Web 服务主流，互联网 Java 容器主流 (如 jsp、do) 。</li>
<li>IIS (Internet information services) ：微软 windows 下的 Web 服务软件 (如 asp、aspx) 。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
</search>
